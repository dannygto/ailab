# SSLAB-äººå·¥æ™ºèƒ½è¾…åŠ©å®éªŒå¹³å°è½¯ä»¶è‘—ä½œæƒç”³è¯·ææ–™

## è½¯ä»¶å…¨ç§°
SSLAB-äººå·¥æ™ºèƒ½è¾…åŠ©å®éªŒå¹³å°è½¯ä»¶ V1.0

## è½¯ä»¶ç®€ç§°
SSLAB-AIå®éªŒå¹³å°

## è½¯ä»¶è‘—ä½œæƒäºº
[å¡«å†™è‘—ä½œæƒäººä¿¡æ¯]

## è½¯ä»¶å¼€å‘å®Œæˆæ—¥æœŸ
2025å¹´6æœˆ24æ—¥

## è½¯ä»¶é¦–æ¬¡å‘è¡¨æ—¥æœŸ
2025å¹´6æœˆ24æ—¥

## è½¯ä»¶åŠŸèƒ½ç‰¹ç‚¹åŠæŠ€æœ¯ç‰¹ç‚¹è¯´æ˜

### è½¯ä»¶åŠŸèƒ½ç‰¹ç‚¹

1. **æ™ºèƒ½å®éªŒè¾…åŠ©åŠŸèƒ½**
   - æä¾›åŸºäºAIçš„å®éªŒè®¾è®¡è¾…åŠ©ï¼ŒåŒ…æ‹¬å®éªŒæ–¹æ¡ˆç”Ÿæˆä¸ä¼˜åŒ–
   - å®éªŒè¿‡ç¨‹ä¸­çš„æ™ºèƒ½é—®ç­”ä¸æŒ‡å¯¼
   - å®éªŒæ•°æ®æ™ºèƒ½åˆ†æä¸ç»“æœè§£é‡Š
   - å®éªŒæŠ¥å‘Šç”Ÿæˆä¸ä¿®æ”¹å»ºè®®

2. **å®éªŒç®¡ç†åŠŸèƒ½**
   - å®éªŒåˆ›å»ºä¸æ¨¡æ¿ç®¡ç†
   - å®éªŒèµ„æºåˆ†é…ä¸ç®¡ç†
   - å®éªŒè¿‡ç¨‹ç›‘æ§ä¸è®°å½•
   - å®éªŒç»“æœè¯„ä¼°ä¸åé¦ˆ

3. **æ•°æ®é‡‡é›†ä¸åˆ†æåŠŸèƒ½**
   - å®éªŒæ•°æ®è‡ªåŠ¨é‡‡é›†
   - å¤šç»´åº¦æ•°æ®å¯è§†åŒ–
   - æ•°æ®ç»Ÿè®¡åˆ†æ
   - å®éªŒæ•°æ®å¯¹æ¯”ä¸è¶‹åŠ¿åˆ†æ

4. **ç”¨æˆ·ç®¡ç†åŠŸèƒ½**
   - å¤šè§’è‰²ç”¨æˆ·ç®¡ç†ï¼ˆå­¦ç”Ÿã€æ•™å¸ˆã€ç®¡ç†å‘˜ï¼‰
   - ç”¨æˆ·æƒé™æ§åˆ¶
   - ç”¨æˆ·è¡Œä¸ºåˆ†æ
   - ä¸ªæ€§åŒ–è®¾ç½®

5. **ç³»ç»Ÿç®¡ç†åŠŸèƒ½**
   - AIæ¨¡å‹é…ç½®ä¸ç®¡ç†
   - ç³»ç»Ÿæ€§èƒ½ç›‘æ§
   - æ•°æ®å¤‡ä»½ä¸æ¢å¤
   - ç³»ç»Ÿæ—¥å¿—ç®¡ç†

### æŠ€æœ¯ç‰¹ç‚¹

1. **å¤šæ¨¡å‹æ™ºèƒ½è°ƒåº¦æŠ€æœ¯**
   - é›†æˆå¤šç§å¤§å‹è¯­è¨€æ¨¡å‹ï¼ŒåŒ…æ‹¬ç«å±±æ–¹èˆŸ Doubao-Seed-1.6-thinking å’Œ DeepSeek Reasoner
   - åŸºäºä»»åŠ¡ç‰¹æ€§çš„æ¨¡å‹é€‰æ‹©ç®—æ³•
   - åŠ¨æ€èµ„æºåˆ†é…ä¸è´Ÿè½½å‡è¡¡
   - æ¨¡å‹æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ–

2. **å‰åç«¯åˆ†ç¦»æ¶æ„**
   - å‰ç«¯åŸºäºReactã€TypeScriptå’ŒMaterial-UIæ„å»º
   - åç«¯é‡‡ç”¨Node.jså’ŒExpressæ¡†æ¶
   - RESTful APIè®¾è®¡
   - WebSocketå®ç°å®æ—¶é€šä¿¡

3. **å¾®æœåŠ¡ç³»ç»Ÿè®¾è®¡**
   - AIæœåŠ¡ã€å®éªŒå¼•æ“ã€å›¾åƒå¤„ç†ç­‰å¤šä¸ªå¾®æœåŠ¡
   - æœåŠ¡é—´é€šä¿¡ä¸ååŒ
   - å®¹å™¨åŒ–éƒ¨ç½²
   - æœåŠ¡å¼¹æ€§ä¼¸ç¼©

4. **æ•°æ®å®‰å…¨ä¸éšç§ä¿æŠ¤**
   - JWTèº«ä»½è®¤è¯
   - æ•°æ®ä¼ è¾“åŠ å¯†
   - è®¿é—®æ§åˆ¶ä¸é€Ÿç‡é™åˆ¶
   - æ•æ„Ÿä¿¡æ¯å¤„ç†

5. **å“åº”å¼UIè®¾è®¡**
   - å¤šè®¾å¤‡é€‚é…
   - ä¸»é¢˜å®šåˆ¶
   - æ— éšœç¢è®¾è®¡
   - ç”¨æˆ·ä½“éªŒä¼˜åŒ–

## è½¯ä»¶æºä»£ç ç‰¹å¾æ€§æè¿°

æœ¬è½¯ä»¶ä½¿ç”¨TypeScriptã€JavaScriptã€Node.jsç­‰å¼€å‘è¯­è¨€ï¼Œé‡‡ç”¨å‰åç«¯åˆ†ç¦»æ¶æ„ã€‚æ ¸å¿ƒæºä»£ç ç‰¹å¾å¦‚ä¸‹ï¼š

### å‰ç«¯æºä»£ç ç‰¹å¾
å‰ç«¯ä½¿ç”¨Reactæ¡†æ¶å¼€å‘ï¼Œé‡‡ç”¨TypeScriptè¯­è¨€ï¼Œä»£ç ç»„ç»‡ç»“æ„æ¸…æ™°ï¼ŒåŒ…å«ä»¥ä¸‹ä¸»è¦æ¨¡å—ï¼š
- ç»„ä»¶åº“ï¼ˆcomponentsï¼‰ï¼šåŒ…å«AIåŠ©æ‰‹ã€å¸ƒå±€ã€è¡¨å•ç­‰é€šç”¨ç»„ä»¶
- é¡µé¢ï¼ˆpagesï¼‰ï¼šåŒ…å«ä»ªè¡¨ç›˜ã€å®éªŒç®¡ç†ã€è®¾ç½®ç­‰é¡µé¢ç»„ä»¶
- æœåŠ¡ï¼ˆservicesï¼‰ï¼šåŒ…å«APIè°ƒç”¨ã€æ•°æ®å¤„ç†ç­‰æœåŠ¡
- çŠ¶æ€ç®¡ç†ï¼ˆstoreï¼‰ï¼šä½¿ç”¨çŠ¶æ€ç®¡ç†åº“ç»´æŠ¤åº”ç”¨çŠ¶æ€
- ç±»å‹å®šä¹‰ï¼ˆtypesï¼‰ï¼šä½¿ç”¨TypeScriptæ¥å£å®šä¹‰æ•°æ®ç»“æ„

### åç«¯æºä»£ç ç‰¹å¾
åç«¯ä½¿ç”¨Node.jså’ŒExpressæ¡†æ¶å¼€å‘ï¼Œé‡‡ç”¨å¾®æœåŠ¡æ¶æ„ï¼ŒåŒ…å«ä»¥ä¸‹ä¸»è¦æ¨¡å—ï¼š
- AIæœåŠ¡ï¼ˆai-serviceï¼‰ï¼šè´Ÿè´£ä¸AIæ¨¡å‹äº¤äº’
- å®éªŒå¼•æ“ï¼ˆexperiment-engineï¼‰ï¼šè´Ÿè´£å®éªŒæµç¨‹ç®¡ç†
- å›¾åƒå¤„ç†ï¼ˆimage-processingï¼‰ï¼šè´Ÿè´£å®éªŒå›¾åƒåˆ†æå¤„ç†
- é€šç”¨åç«¯æœåŠ¡ï¼šæä¾›åŸºç¡€APIæ”¯æŒ

### å…³é”®ç®—æ³•ç‰¹å¾
- å¤šæ¨¡å‹æ™ºèƒ½è°ƒåº¦ç®—æ³•ï¼šåŸºäºä»»åŠ¡ç‰¹æ€§å’Œæ¨¡å‹èƒ½åŠ›çš„åŒ¹é…ç®—æ³•
- å®éªŒæ•°æ®åˆ†æç®—æ³•ï¼šç”¨äºå¤„ç†å’Œåˆ†æå®éªŒæ•°æ®çš„ç»Ÿè®¡å’Œæœºå™¨å­¦ä¹ ç®—æ³•
- èµ„æºè°ƒåº¦ç®—æ³•ï¼šä¼˜åŒ–å®éªŒèµ„æºåˆ†é…çš„ç®—æ³•

## è½¯ä»¶ç™»è®°ææ–™å½¢å¼

1. æºç¨‹åºï¼ˆæºä»£ç ï¼‰
   - å‰ç«¯æºä»£ç ï¼šReactç»„ä»¶ã€æœåŠ¡ã€çŠ¶æ€ç®¡ç†ç­‰
   - åç«¯æºä»£ç ï¼šAPIæœåŠ¡ã€ä¸­é—´ä»¶ã€æ•°æ®å¤„ç†ç­‰
   - é…ç½®æ–‡ä»¶ï¼šç¯å¢ƒé…ç½®ã€é¡¹ç›®é…ç½®ç­‰

2. å¯æ‰§è¡Œç¨‹åº
   - å‰ç«¯æ„å»ºåŒ…
   - åç«¯æœåŠ¡ç¨‹åº
   - Dockerå®¹å™¨é…ç½®

3. è½¯ä»¶è¯´æ˜æ–‡æ¡£
   - ç³»ç»Ÿè®¾è®¡æ–‡æ¡£
   - APIæ–‡æ¡£
   - ç”¨æˆ·ä½¿ç”¨æ‰‹å†Œ
   - éƒ¨ç½²æŒ‡å—

## æºä»£ç 

æœ¬èŠ‚åŒ…å«SSLAB-AIå®éªŒå¹³å°è½¯ä»¶çš„æ ¸å¿ƒä»£ç æ–‡ä»¶ï¼ŒæŒ‰ç…§è½¯ä»¶è‘—ä½œæƒç”³è¯·è¦æ±‚ï¼Œæä¾›å‰30é¡µå’Œå30é¡µå®Œæ•´æºä»£ç ã€‚

### å‰30é¡µæºä»£ç 

#### æ–‡ä»¶1: backend/src/server.ts - åç«¯ä¸»æœåŠ¡å™¨ï¼ˆå¼€å§‹éƒ¨åˆ†ï¼‰
```typescript
```typescript
/**
 * ğŸš€ åç«¯ä¸»æœåŠ¡å™¨ - å®Œæˆåº¦: 96%
 * 
 * âœ… å·²å®ŒæˆåŠŸèƒ½:
 * - Expressåº”ç”¨æ¡†æ¶é…ç½®
 * - WebSocketå®æ—¶é€šä¿¡æœåŠ¡
 * - RESTful APIè·¯ç”±ç³»ç»Ÿ
 * - è·¨åŸŸCORSé…ç½®
 * - å®‰å…¨ä¸­é—´ä»¶(Helmet)
 * - è¯·æ±‚æ—¥å¿—è®°å½•(Morgan)
 * - AIåŠ©æ‰‹æœåŠ¡é›†æˆ
 * - è®¾å¤‡ç®¡ç†API
 * - æ¨¡æ¿ç®¡ç†API
 * - æŒ‡å¯¼ç³»ç»ŸAPI
 * - é”™è¯¯å¤„ç†ä¸­é—´ä»¶
 * 
 * ğŸ”„ å¾…å®Œå–„åŠŸèƒ½:
 * - æ•°æ®åº“è¿æ¥æ± ä¼˜åŒ–
 * - æ›´å¤šä¸šåŠ¡APIæ¥å£
 * - æ–‡ä»¶ä¸Šä¼ å¤„ç†
 * - ç¼“å­˜æœºåˆ¶é›†æˆ
 * 
 * ğŸ“Š æŠ€æœ¯äº®ç‚¹:
 * - TypeScriptç±»å‹å®‰å…¨
 * - å¾®æœåŠ¡æ¶æ„è®¾è®¡
 * - å®æ—¶åŒå‘é€šä¿¡
 * - æ¨¡å—åŒ–è·¯ç”±ç®¡ç†
 * - ç¯å¢ƒé…ç½®ç®¡ç†
 */

import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import { Server as WebSocketServer } from 'ws';
import http from 'http';
import dotenv from 'dotenv';
import { aiService } from './services/ai.service';
import guidanceRoutes from './routes/guidance.routes';
import deviceRoutes from './routes/device.routes';
import templateRoutes from './routes/template.routes';

// åŠ è½½ç¯å¢ƒå˜é‡
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3002;

// åˆ›å»ºHTTPæœåŠ¡å™¨
const server = http.createServer(app);

// è®¾ç½®WebSocketæœåŠ¡å™¨
const wss = new WebSocketServer({ server, path: '/ws' });

// WebSocketè¿æ¥å¤„ç†
wss.on('connection', (ws) => {
  console.log('WebSocketå®¢æˆ·ç«¯å·²è¿æ¥');
  
  // å‘é€åˆå§‹è¿æ¥æˆåŠŸæ¶ˆæ¯
  ws.send(JSON.stringify({ 
    type: 'connection',
    status: 'connected',
    message: 'WebSocketè¿æ¥å·²å»ºç«‹',
    timestamp: new Date().toISOString()
  }));
  
  // ç›‘å¬å®¢æˆ·ç«¯æ¶ˆæ¯
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message.toString());
      console.log('æ”¶åˆ°WebSocketæ¶ˆæ¯:', data);
      
      // æ ¹æ®æ¶ˆæ¯ç±»å‹å¤„ç†
      if (data.type === 'ping') {
        ws.send(JSON.stringify({
          type: 'pong',
          timestamp: new Date().toISOString()
        }));
      } else if (data.type === 'ai-request') {
        // æ¨¡æ‹ŸAIå¤„ç†
        setTimeout(() => {
          ws.send(JSON.stringify({
            type: 'ai-response',
            requestId: data.requestId,
            message: 'è¿™æ˜¯æ¥è‡ªAIåŠ©æ‰‹çš„å“åº”',
            timestamp: new Date().toISOString()
          }));
        }, 1000);
      }
    } catch (err) {
      console.error('å¤„ç†WebSocketæ¶ˆæ¯æ—¶å‡ºé”™:', err);
      ws.send(JSON.stringify({ 
        type: 'error',
        message: 'æ¶ˆæ¯æ ¼å¼é”™è¯¯',
        timestamp: new Date().toISOString()
      }));
    }
  });
  
  // å¤„ç†è¿æ¥å…³é—­
  ws.on('close', () => {
    console.log('WebSocketå®¢æˆ·ç«¯å·²æ–­å¼€è¿æ¥');
  });
  
  // å¤„ç†é”™è¯¯
  ws.on('error', (error) => {
    console.error('WebSocketé”™è¯¯:', error);
  });
});

// å®‰å…¨ä¸­é—´ä»¶
app.use(helmet());

// CORSé…ç½® - ä¿®å¤å‰ç«¯ç«¯å£ä¸º3000
app.use(cors({
  origin: [
    process.env.FRONTEND_URL || "http://localhost:3000", 
    "http://localhost:3001", // å¤‡ç”¨ç«¯å£
    "http://192.168.0.145:3000",
    "http://192.168.0.145:3001"
  ],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
}));

// è¯·æ±‚æ—¥å¿—
app.use(morgan('combined'));

// JSONè§£æ
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// åŸºç¡€è·¯ç”±
app.get('/', (req, res) => {
  res.json({ 
    message: 'äººå·¥æ™ºèƒ½è¾…åŠ©å®éªŒå¹³å°åç«¯API - æ™®æ•™ç‰ˆ',
    version: '1.0.0',
    edition: 'basic',
    timestamp: new Date().toISOString()
  });
});

// å¥åº·æ£€æŸ¥
app.get('/health', (req, res) => {
  res.json({ 
    status: 'healthy',
    timestamp: new Date().toISOString()
  });
});

// APIå¥åº·æ£€æŸ¥
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'healthy',
    timestamp: new Date().toISOString()
  });
});

// AIåŠ©æ‰‹æ¨¡å‹æµ‹è¯•è¿æ¥ç«¯ç‚¹
app.post('/api/ai-assistant/test-connection', (req, res) => {
  try {
    const { model, config, specificParams } = req.body;

    console.log(`ğŸ§ª æµ‹è¯•AIæ¨¡å‹è¿æ¥: ${model}`);

    // åœ¨è¿™é‡Œæˆ‘ä»¬åªæ˜¯éªŒè¯è¯·æ±‚æ ¼å¼ï¼Œå®é™…ç¯å¢ƒä¸­åº”è¯¥å°è¯•å®é™…è¿æ¥æ¨¡å‹API
    if (!model || !config || !config.apiKey) {
      return res.status(400).json({
        success: false,
        message: 'ç¼ºå°‘å¿…è¦å‚æ•°: æ¨¡å‹åç§°æˆ–APIå¯†é’¥'
      });
    }

    // æ ¹æ®ä¸åŒçš„æ¨¡å‹è¿”å›ä¸åŒçš„tokené™åˆ¶ä¿¡æ¯
    let tokenLimits = {};
    if (model === 'doubao-seed-1-6-thinking-250615') {
      tokenLimits = {
        contextWindow: 256000,
        inputTokenLimit: 240000,
        outputTokenLimit: 16000
      };
    } else if (model === 'deepseek-reasoner') {
      tokenLimits = {
        contextWindow: 128000, 
        inputTokenLimit: 120000,
        outputTokenLimit: 8000
      };
    } else {
      tokenLimits = {
        contextWindow: 32000,
        inputTokenLimit: 30000,
        outputTokenLimit: 2000
      };
    }

    // æ¨¡æ‹ŸæˆåŠŸå“åº”
    return res.json({
      success: true,
      message: `æˆåŠŸè¿æ¥åˆ° ${model}`,
      tokenLimits
    });
  } catch (error: any) {
    console.error('AIæ¨¡å‹è¿æ¥æµ‹è¯•å¤±è´¥:', error);
    return res.status(500).json({
      success: false,
      message: error.message || 'AIæ¨¡å‹è¿æ¥æµ‹è¯•å¤±è´¥'
    });
  }
});

// ä»ªè¡¨ç›˜æœ€è¿‘å®éªŒ
app.get('/api/dashboard/recent-experiments', (req, res) => {
  const limit = parseInt(req.query.limit as string) || 5;
  
  const experiments = [
    {
      id: '1',
      name: 'ç£é“æ€§è´¨æ¢ç©¶',
      description: 'è§‚å¯Ÿç£é“çš„å¸å¼•åŠ›å’Œç£ææ€§è´¨ï¼Œæ¢ç©¶ç£é“åœ¨æ—¥å¸¸ç”Ÿæ´»ä¸­çš„åº”ç”¨',
      type: 'observation',
      status: 'completed',
      userId: '1',
      createdAt: '2025-06-20T10:00:00Z',
      updatedAt: '2025-06-20T11:30:00Z'
    },
    {
      id: '2',
      name: 'æ¤ç‰©å…‰åˆä½œç”¨è§‚å¯Ÿ',
      description: 'é€šè¿‡è®¾è®¡å®éªŒï¼Œè§‚å¯Ÿä¸åŒå…‰ç…§æ¡ä»¶ä¸‹æ¤ç‰©çš„å…‰åˆä½œç”¨é€Ÿç‡å˜åŒ–',
      type: 'observation',
      status: 'running',
      userId: '2',
      createdAt: '2025-06-21T09:00:00Z',
      updatedAt: '2025-06-21T09:30:00Z'
    },
    {
      id: '3',
      name: 'æ°´çš„ç”µè§£å®éªŒ',
      description: 'é€šè¿‡ç”µè§£æ°´ï¼Œç ”ç©¶æ°´åˆ†å­çš„ç»„æˆå’ŒåŒ–å­¦ååº”è¿‡ç¨‹',
      type: 'chemical',
      status: 'completed',
      userId: '1',
      createdAt: '2025-06-19T14:00:00Z',
      updatedAt: '2025-06-19T15:30:00Z'
    },
    {
      id: '4',
      name: 'å£°éŸ³ä¼ æ’­å®éªŒ',
      description: 'ç ”ç©¶å£°éŸ³åœ¨ä¸åŒä»‹è´¨ä¸­çš„ä¼ æ’­ç‰¹æ€§',
      type: 'physics',
      status: 'failed',
      userId: '3',
      createdAt: '2025-06-18T13:00:00Z',
      updatedAt: '2025-06-18T14:00:00Z'
    },
    {
      id: '5',
      name: 'é‡åŠ›åŠ é€Ÿåº¦æµ‹é‡',
      description: 'ä½¿ç”¨è‡ªç”±è½ä½“å®éªŒæµ‹é‡é‡åŠ›åŠ é€Ÿåº¦',
      type: 'physics',
      status: 'completed',
      userId: '2',
      createdAt: '2025-06-17T10:00:00Z',
      updatedAt: '2025-06-17T11:00:00Z'
    }
  ];
  
  res.json(experiments.slice(0, limit));
});

#### æ–‡ä»¶2: backend/src/services/ai.service.ts - AIæœåŠ¡æ¨¡å—
```typescript
import axios from 'axios';

// AIæ¨¡å‹é…ç½®æ¥å£
export interface AIModelConfig {
  id: string;
  name: string;
  provider: string;
  endpoint: string;
  apiKey?: string;
  available: boolean;
  maxTokens: number;
  temperature: number;
  description: string;
}

// èŠå¤©æ¶ˆæ¯æ¥å£
export interface ChatMessage {
  role: 'system' | 'user' | 'assistant';
  content: string | Array<{
    type: 'text' | 'image_url';
    text?: string;
    image_url?: {
      url: string;
    };
  }>;
}

// AIå“åº”æ¥å£
export interface AIResponse {
  content: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  model: string;
  finishReason?: string;
}

export class AIService {
  private models: Map<string, AIModelConfig> = new Map();

  constructor() {
    this.initializeModels();
  }

  private initializeModels() {
    // ç«å±±æ–¹èˆŸ - è±†åŒ…æ¨¡å‹
    this.models.set('doubao-seed', {
      id: 'doubao-seed',
      name: 'è±†åŒ… (ç«å±±æ–¹èˆŸ)',
      provider: 'ç«å±±æ–¹èˆŸ',
      endpoint: 'https://ark.cn-beijing.volces.com/api/v3/chat/completions',
      apiKey: process.env.ARK_API_KEY,
      available: !!process.env.ARK_API_KEY,
      maxTokens: 4096,
      temperature: 0.7,
      description: 'å­—èŠ‚è·³åŠ¨è±†åŒ…å¤§æ¨¡å‹ï¼Œæ”¯æŒä¸­æ–‡å¯¹è¯å’Œå¤šæ¨¡æ€'
    });

    // DeepSeek æ¨¡å‹
    this.models.set('deepseek-chat', {
      id: 'deepseek-chat',
      name: 'DeepSeek Chat',
      provider: 'DeepSeek',
      endpoint: 'https://api.deepseek.com/chat/completions',
      apiKey: process.env.DEEPSEEK_API_KEY,
      available: !!process.env.DEEPSEEK_API_KEY,
      maxTokens: 4096,
      temperature: 0.7,
      description: 'DeepSeek æ·±åº¦æ±‚ç´¢å¤§æ¨¡å‹ï¼Œæ“…é•¿æ¨ç†å’Œç¼–ç¨‹'
    });
  }

  // è·å–å¯ç”¨æ¨¡å‹åˆ—è¡¨
  public getAvailableModels(): AIModelConfig[] {
    return Array.from(this.models.values()).filter(model => model.available);
  }

  // è·å–æŒ‡å®šæ¨¡å‹é…ç½®
  public getModelConfig(modelId: string): AIModelConfig | undefined {
    return this.models.get(modelId);
  }

  // ç«å±±æ–¹èˆŸAPIè°ƒç”¨
  private async callVolcanicArk(
    messages: ChatMessage[],
    config: AIModelConfig
  ): Promise<AIResponse> {
    try {
      const response = await axios.post(
        config.endpoint,
        {
          model: 'doubao-seed-1-6-thinking-250615',
          messages: messages,
          max_tokens: config.maxTokens,
          temperature: config.temperature,
          stream: false
        },
        {
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${config.apiKey}`
          },
          timeout: 30000
        }
      );

      const data = response.data;
      return {
        content: data.choices[0].message.content,
        usage: data.usage ? {
          promptTokens: data.usage.prompt_tokens,
          completionTokens: data.usage.completion_tokens,
          totalTokens: data.usage.total_tokens
        } : undefined,
        model: config.id,
        finishReason: data.choices[0].finish_reason
      };
    } catch (error: any) {
      console.error('ç«å±±æ–¹èˆŸAPIè°ƒç”¨å¤±è´¥:', error.response?.data || error.message);
      throw new Error(`ç«å±±æ–¹èˆŸAPIè°ƒç”¨å¤±è´¥: ${error.response?.data?.error?.message || error.message}`);
    }
  }

  // DeepSeek APIè°ƒç”¨
  private async callDeepSeek(
    messages: ChatMessage[],
    config: AIModelConfig
  ): Promise<AIResponse> {
    try {
      const response = await axios.post(
        config.endpoint,
        {
          model: 'deepseek-chat',
          messages: messages,
          max_tokens: config.maxTokens,
          temperature: config.temperature,
          stream: false
        },
        {
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${config.apiKey}`
          },
          timeout: 30000
        }
      );

      const data = response.data;
      return {
        content: data.choices[0].message.content,
        usage: data.usage ? {
          promptTokens: data.usage.prompt_tokens,
          completionTokens: data.usage.completion_tokens,
          totalTokens: data.usage.total_tokens
        } : undefined,
        model: config.id,
        finishReason: data.choices[0].finish_reason
      };
    } catch (error: any) {
      console.error('DeepSeek APIè°ƒç”¨å¤±è´¥:', error.response?.data || error.message);
      throw new Error(`DeepSeek APIè°ƒç”¨å¤±è´¥: ${error.response?.data?.error?.message || error.message}`);
    }
  }

  // ä¸»è¦èŠå¤©æ¥å£
  public async chat(
    messages: ChatMessage[],
    modelId: string = 'deepseek-chat',
    options?: {
      temperature?: number;
      maxTokens?: number;
    }
  ): Promise<AIResponse> {
    const model = this.getModelConfig(modelId);
    
    if (!model) {
      throw new Error(`æ¨¡å‹ ${modelId} ä¸å­˜åœ¨`);
    }

    if (!model.available) {
      throw new Error(`æ¨¡å‹ ${modelId} ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥APIå¯†é’¥é…ç½®`);
    }

    // åº”ç”¨é€‰é¡¹å‚æ•°
    const effectiveConfig = {
      ...model,
      temperature: options?.temperature ?? model.temperature,
      maxTokens: options?.maxTokens ?? model.maxTokens
    };

    // æ ¹æ®ä¸åŒæä¾›å•†è°ƒç”¨ç›¸åº”çš„API
    switch (model.provider) {
      case 'ç«å±±æ–¹èˆŸ':
        return await this.callVolcanicArk(messages, effectiveConfig);
      case 'DeepSeek':
        return await this.callDeepSeek(messages, effectiveConfig);
      default:
        throw new Error(`ä¸æ”¯æŒçš„AIæä¾›å•†: ${model.provider}`);
    }
  }

  // ç”Ÿæˆæ–‡æœ¬ (å…¼å®¹æ—§æ¥å£)
  public async generateText(
    modelId: string,
    messages: ChatMessage[],
    options?: {
      temperature?: number;
      maxTokens?: number;
    }
  ): Promise<AIResponse> {
    return await this.chat(messages, modelId, options);
  }

  // æµ‹è¯•è¿æ¥ (å…¼å®¹æ—§æ¥å£)
  public async testConnection(aiConfig: {
    selectedModel: string;
    apiKey: string;
    temperature?: number;
    maxTokens?: number;
  }): Promise<{ success: boolean; message: string }> {
    try {
      // ä¸´æ—¶æ›´æ–°APIå¯†é’¥
      const model = this.getModelConfig(aiConfig.selectedModel);
      if (!model) {
        return {
          success: false,
          message: `æ¨¡å‹ ${aiConfig.selectedModel} ä¸å­˜åœ¨`
        };
      }

      const tempModel: AIModelConfig = {
        ...model,
        apiKey: aiConfig.apiKey,
        available: true,
        temperature: aiConfig.temperature || model.temperature,
        maxTokens: aiConfig.maxTokens || model.maxTokens
      };

      const testMessages: ChatMessage[] = [
        {
          role: 'user',
          content: 'ä½ å¥½ï¼Œè¯·ç®€å•å›å¤ä¸€ä¸‹ç¡®è®¤è¿æ¥æ­£å¸¸ã€‚'
        }
      ];

      // æ ¹æ®ä¸åŒæä¾›å•†è°ƒç”¨ç›¸åº”çš„API
      let response: AIResponse;
      switch (model.provider) {
        case 'ç«å±±æ–¹èˆŸ':
          response = await this.callVolcanicArk(testMessages, tempModel);
          break;
        case 'DeepSeek':
          response = await this.callDeepSeek(testMessages, tempModel);
          break;
        default:
          return {
            success: false,
            message: `ä¸æ”¯æŒçš„AIæä¾›å•†: ${model.provider}`
          };
      }
      
      return {
        success: true,
        message: `æ¨¡å‹ ${aiConfig.selectedModel} è¿æ¥æˆåŠŸï¼Œå“åº”: ${response.content.substring(0, 50)}...`
      };
    } catch (error: any) {
      return {
        success: false,
        message: `æ¨¡å‹ ${aiConfig.selectedModel} è¿æ¥å¤±è´¥: ${error.message}`
      };
    }
  }
}

// å¯¼å‡ºå•ä¾‹å®ä¾‹
export const aiService = new AIService();

#### æ–‡ä»¶3: frontend/src/App.tsx - å‰ç«¯ä¸»åº”ç”¨
```tsx
import React, { useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import { CssBaseline, Box } from '@mui/material';
import { Toaster } from 'react-hot-toast';
import { QueryClient, QueryClientProvider } from 'react-query';
import { HelmetProvider } from 'react-helmet-async';
import { ErrorBoundary } from 'react-error-boundary';

// å¯¼å…¥ç»„ä»¶
import MainLayout from './components/layout/MainLayout';
import PWAPrompt from './components/common/PWAPrompt';

// å¯¼å…¥é¡µé¢
import Dashboard from './pages/Dashboard';
import Login from './pages/Login';
import Register from './pages/Register';
import ExperimentList from './pages/experiments/ExperimentList';
import ExperimentDetail from './pages/experiments/ExperimentDetail';
import ExperimentCreate from './pages/experiments/ExperimentCreate';
import TemplateLibrary from './pages/templates/TemplateLibrary';
import TemplateDetail from './pages/templates/TemplateDetail';
import TemplateCreate from './pages/templates/TemplateCreate';
import AIAssistant from './pages/AIAssistant';
import ApiIntegrationCheck from './pages/ApiIntegrationCheck';
import ResourceManagement from './pages/resources/ResourceManagement';
import DataCollectionAnalysis from './pages/data/DataCollectionAnalysis';
import GuidanceSystem from './pages/guidance/GuidanceSystem';
import DeviceManagement from './pages/devices/DeviceManagement';
// import ImageProcessing from './pages/ImageProcessing';
// import Templates from './pages/Templates';
// import Analytics from './pages/Analytics';
// import Users from './pages/Users';
import Settings from './pages/Settings';
// import Profile from './pages/Profile';
import Help from './pages/Help';
// import About from './pages/About';

// åˆ›å»ºReact Queryå®¢æˆ·ç«¯
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
});

// é”™è¯¯è¾¹ç•Œç»„ä»¶
const ErrorFallback: React.FC<{ error: Error; resetErrorBoundary: () => void }> = ({
  error,
  resetErrorBoundary,
}) => {
  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        minHeight: '100vh',
        p: 3,
      }}
    >
      <h2>å‡ºç°äº†ä¸€äº›é—®é¢˜</h2>
      <pre style={{ color: 'red' }}>{error.message}</pre>
      <button onClick={resetErrorBoundary}>é‡è¯•</button>
    </Box>
  );
};

// å—ä¿æŠ¤çš„è·¯ç”±ç»„ä»¶
const ProtectedRoute: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { isAuthenticated } = useUserStore();

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

// è¿”å›å¹¶é€€å‡º
  return <>{children}</>;
};

const App: React.FC = () => {
  const { theme: appTheme } = useThemeStore();

  // åˆ›å»ºä¸»é¢˜
  const theme = createTheme({
    palette: {
      mode: appTheme.mode,
      primary: {
        main: appTheme.primaryColor,
      },
      secondary: {
        main: appTheme.secondaryColor,
      },
      background: {
        default: appTheme.backgroundColor,
        paper: appTheme.mode === 'dark' ? '#1e1e1e' : '#ffffff',
      },
      text: {
        primary: appTheme.textColor,
      },
    },
    typography: {
      fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
      h1: {
        fontSize: '2.5rem',
        fontWeight: 600,
      },
      h2: {
        fontSize: '2rem',
        fontWeight: 600,
      },

#### æ–‡ä»¶4: frontend/src/services/api.ts - å‰ç«¯APIæœåŠ¡æ¨¡å—ï¼ˆç¬¬ä¸€éƒ¨åˆ†ï¼‰
```typescript
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { toast } from 'react-hot-toast';

// APIå“åº”æ¥å£
export interface ApiResponse<T = any> {
  success: boolean;
  data: T;
  message: string;
  code: number;
  timestamp: string;
}

// åˆ†é¡µå“åº”æ¥å£
export interface PaginatedResponse<T> {
  items: T[];
  total: number;
  page: number;
  pageSize: number;
  totalPages: number;
}

// APIæœåŠ¡ç±»
class ApiService {
  private apiClient: AxiosInstance;
  private baseURL: string;

  constructor() {
    // æ ¹æ®ç¯å¢ƒç¡®å®šAPIåŸºç¡€URL
    this.baseURL = process.env.REACT_APP_API_URL || 'http://localhost:3002/api';
    
    // åˆ›å»ºaxioså®ä¾‹
    this.apiClient = axios.create({
      baseURL: this.baseURL,
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json',
      }
    });

    // é…ç½®è¯·æ±‚æ‹¦æˆªå™¨
    this.apiClient.interceptors.request.use(
      (config) => {
        // æ·»åŠ è®¤è¯token
        const token = localStorage.getItem('token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        
        // æ·»åŠ è¯·æ±‚IDå’Œæ—¶é—´æˆ³
        const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        config.headers['X-Request-ID'] = requestId;
        config.headers['X-Timestamp'] = new Date().toISOString();

        return config;
      },
      (error) => {
        console.error('è¯·æ±‚æ‹¦æˆªå™¨é”™è¯¯:', error);
        return Promise.reject(error);
      }
    );

    // é…ç½®å“åº”æ‹¦æˆªå™¨
    this.apiClient.interceptors.response.use(
      (response) => {
        return response;
      },
      (error) => {
        this.handleError(error);
        return Promise.reject(error);
      }
    );
  }

  // é”™è¯¯å¤„ç†
  private handleError(error: any): void {
    if (error.response) {
      const { status, data } = error.response;
      
      switch (status) {
        case 401:
          // æœªæˆæƒï¼Œæ¸…é™¤tokenå¹¶é‡å®šå‘åˆ°ç™»å½•é¡µ
          localStorage.removeItem('token');
          localStorage.removeItem('user');
          
          if (window.location.pathname !== '/login') {
            toast.error('ä¼šè¯å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
            window.location.href = '/login';
          }
          break;
        case 403:
          toast.error('æ‚¨æ²¡æœ‰æƒé™æ‰§è¡Œæ­¤æ“ä½œ');
          break;
        case 404:
          // APIæ£€æŸ¥æ—¶çš„404é”™è¯¯é™é»˜å¤„ç†
          if (error.config?.url?.includes('health') || 
              error.config?.url?.includes('chat') ||
              error.config?.url?.includes('auth/me')) {
            console.warn(`âš ï¸ APIç«¯ç‚¹ ${error.config.url} ä¸å­˜åœ¨ï¼Œä½¿ç”¨é™çº§æ¨¡å¼`);
            return;
          }
          toast.error('è¯·æ±‚çš„èµ„æºä¸å­˜åœ¨');
          break;
        case 500:
          toast.error('æœåŠ¡å™¨å†…éƒ¨é”™è¯¯');
          break;
        default:
          // å¯¹äºAPIæ£€æŸ¥ç›¸å…³çš„é”™è¯¯ï¼Œé™ä½æç¤ºçº§åˆ«
          if (error.config?.url?.includes('health') || 
              error.config?.url?.includes('chat')) {
            console.warn(`âš ï¸ APIå“åº”å¼‚å¸¸: ${data?.message || 'æœåŠ¡æš‚æ—¶ä¸å¯ç”¨'}`);
            return;
          }
          toast.error(data?.message || 'è¯·æ±‚å¤±è´¥');
      }
    } else {
      console.error('è¯·æ±‚é…ç½®é”™è¯¯:', error.message);
    }
  }

  // é€šç”¨è¯·æ±‚æ–¹æ³•
  private async request<T>(config: AxiosRequestConfig): Promise<T> {
    try {
      const response: AxiosResponse<ApiResponse<T>> = await this.apiClient.request(config);
      return response.data.data as T;
    } catch (error) {
      throw error;
    }
  }

  // é€šç”¨HTTPæ–¹æ³•
  async get<T = any>(url: string, params?: any): Promise<T> {
    return this.request<T>({
      method: 'GET',
      url,
      params,
    });
  }

  async post<T = any>(url: string, data?: any, config?: Partial<AxiosRequestConfig>): Promise<T> {
    return this.request<T>({
      method: 'POST',
      url,
      data,
      ...config,
    });
  }

  async put<T = any>(url: string, data?: any): Promise<T> {
    return this.request<T>({
      method: 'PUT',
      url,
      data,
    });
  }

  async delete<T = any>(url: string, params?: any): Promise<T> {
    return this.request<T>({
      method: 'DELETE',
      url,
      params,
    });
  }

  async patch<T = any>(url: string, data?: any): Promise<T> {
    return this.request<T>({
      method: 'PATCH',
      url,
      data,
    });
  }

  // å¥åº·æ£€æŸ¥API
  async checkHealth(): Promise<{ status: string; version: string }> {
    try {
      return await this.get('/health');
    } catch (error) {
      console.warn('å¥åº·æ£€æŸ¥å¤±è´¥:', error);
      return { status: 'unhealthy', version: 'unknown' };
    }
  }

  // AIåŠ©æ‰‹API
  async testAIConnection(modelConfig: {
    selectedModel: string;
    apiKey: string;
    temperature?: number;
    maxTokens?: number;
  }): Promise<{ success: boolean; message: string; tokenLimits?: any }> {
    try {
      const response = await this.post('/ai-assistant/test-connection', {
        model: modelConfig.selectedModel,
        config: {
          apiKey: modelConfig.apiKey,
          temperature: modelConfig.temperature || 0.7,
          maxTokens: modelConfig.maxTokens || 2000
        }
      });
      return response;
    } catch (error: any) {
      return {
        success: false,
        message: error.response?.data?.message || 'è¿æ¥æµ‹è¯•å¤±è´¥'
      };
    }
  }
}

// åˆ›å»ºAPIæœåŠ¡å®ä¾‹
const apiService = new ApiService();
export default apiService;

#### æ–‡ä»¶5: frontend/src/pages/settings/AIModelSettings.tsx - AIæ¨¡å‹è®¾ç½®é¡µé¢
```tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Paper,
  Typography,
  Grid,
  Card,
  CardContent,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  TextField,
  Button,
  Chip,
  Alert,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  List,
  ListItem,
  ListItemText,
  ListItemIcon
} from '@mui/material';

import {
  ExpandMore as ExpandMoreIcon,
  Settings as SettingsIcon,
  Check as CheckIcon,
  Error as ErrorIcon,
  Info as InfoIcon,
  Security as SecurityIcon
} from '@mui/icons-material';

import { AI_MODELS, AI_PROVIDERS, DEFAULT_AI_CONFIG } from '../../config/ai-models';
import apiService from '../../services/api';

interface AIConfig {
  selectedModel: string;
  apiKey: string;
  temperature: number;
  maxTokens: number;
  systemPrompt: string;
  customEndpoint?: string;
}

const AIModelSettings: React.FC = () => {
  const [config, setConfig] = useState<AIConfig>(DEFAULT_AI_CONFIG);
  const [selectedProvider, setSelectedProvider] = useState<string>('ç«å±±æ–¹èˆŸ'); // é»˜è®¤ç«å±±æ–¹èˆŸï¼Œå¯¹åº”é»˜è®¤æ¨¡å‹
  const [testResult, setTestResult] = useState<{ success: boolean; message: string } | null>(null);
  const [isTesting, setIsTesting] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [tokenLimits, setTokenLimits] = useState<any>(null);
  const [providerModels, setProviderModels] = useState<any[]>([]);

  // è½½å…¥ä¿å­˜çš„é…ç½®
  useEffect(() => {
    loadSavedConfig();
  }, []);

  // æ ¹æ®é€‰æ‹©çš„æä¾›å•†æ›´æ–°å¯ç”¨æ¨¡å‹
  useEffect(() => {
    updateProviderModels();
  }, [selectedProvider]);

  // è½½å…¥ä¿å­˜çš„é…ç½®
  const loadSavedConfig = () => {
    try {
      const savedConfig = localStorage.getItem('ai_config');
      if (savedConfig) {
        const parsedConfig = JSON.parse(savedConfig);
        setConfig(parsedConfig);
        
        // ç¡®å®šæä¾›å•†
        const model = AI_MODELS.find(m => m.id === parsedConfig.selectedModel);
        if (model) {
          setSelectedProvider(model.provider);
        }
      }
    } catch (error) {
      console.error('è½½å…¥AIé…ç½®å¤±è´¥:', error);
    }
  };

  // æ›´æ–°æä¾›å•†æ¨¡å‹åˆ—è¡¨
  const updateProviderModels = () => {
    const models = AI_MODELS.filter(model => model.provider === selectedProvider);
    setProviderModels(models);
    
    // å¦‚æœå½“å‰é€‰æ‹©çš„æ¨¡å‹ä¸å±äºå½“å‰æä¾›å•†ï¼Œåˆ™è‡ªåŠ¨é€‰æ‹©è¯¥æä¾›å•†çš„ç¬¬ä¸€ä¸ªæ¨¡å‹
    const currentModelBelongsToProvider = models.some(m => m.id === config.selectedModel);
    if (!currentModelBelongsToProvider && models.length > 0) {
      handleChange('selectedModel')(models[0].id);
    }
  };

  // å¤„ç†è¾“å…¥å˜åŒ–
  const handleChange = (prop: keyof AIConfig) => (event: any) => {
    const value = event.target.value;
    setConfig({ ...config, [prop]: value });
    
    // å¦‚æœæ›´æ”¹äº†æ¨¡å‹ï¼Œæ£€æŸ¥å¹¶æ›´æ–°æä¾›å•†
    if (prop === 'selectedModel') {
      const model = AI_MODELS.find(m => m.id === value);
      if (model && model.provider !== selectedProvider) {
        setSelectedProvider(model.provider);
      }
    }
    
    // æ¸…é™¤æµ‹è¯•ç»“æœ
    setTestResult(null);
  };

  // å¤„ç†æä¾›å•†å˜æ›´
  const handleProviderChange = (event: any) => {
    const newProvider = event.target.value;
    setSelectedProvider(newProvider);
    
    // æ¸…é™¤æµ‹è¯•ç»“æœ
    setTestResult(null);
  };

  // ä¿å­˜é…ç½®
  const saveConfig = () => {
    try {
      setIsSaving(true);
      localStorage.setItem('ai_config', JSON.stringify(config));
      
      // æ˜¾ç¤ºä¿å­˜æˆåŠŸ
      setTimeout(() => {
        setIsSaving(false);
        toast.success('AIæ¨¡å‹é…ç½®å·²ä¿å­˜');
      }, 500);
    } catch (error) {
      console.error('ä¿å­˜AIé…ç½®å¤±è´¥:', error);
      setIsSaving(false);
      toast.error('ä¿å­˜é…ç½®å¤±è´¥');
    }
  };

  // æµ‹è¯•è¿æ¥
  const testConnection = async () => {
    try {
      setIsTesting(true);
      setTestResult(null);
      
      const result = await apiService.testAIConnection({
        selectedModel: config.selectedModel,
        apiKey: config.apiKey,
        temperature: config.temperature,
        maxTokens: config.maxTokens
      });
      
      setTestResult(result);
      if (result.tokenLimits) {
        setTokenLimits(result.tokenLimits);
      }
    } catch (error) {
      console.error('æµ‹è¯•è¿æ¥å¤±è´¥:', error);
      setTestResult({
        success: false,
        message: 'æµ‹è¯•è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥'
      });
    } finally {
      setIsTesting(false);
    }
  };

  return (
    <Box sx={{ py: 3 }}>
      <Typography variant="h4" gutterBottom>
        <SettingsIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
        AIæ¨¡å‹è®¾ç½®
      </Typography>
      
      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="subtitle1" gutterBottom>
          é…ç½®AIæ¨¡å‹è¿æ¥å’Œå‚æ•°ï¼Œç”¨äºå®éªŒè®¾è®¡ã€æ•°æ®åˆ†æå’Œæ™ºèƒ½è¾…åŠ©åŠŸèƒ½
        </Typography>
        
        <Grid container spacing={3} sx={{ mt: 2 }}>
          {/* AIæä¾›å•†é€‰æ‹© */}
          <Grid item xs={12} md={6}>
            <FormControl fullWidth>
              <InputLabel>AIæä¾›å•†</InputLabel>
              <Select
                value={selectedProvider}
                onChange={handleProviderChange}
                label="AIæä¾›å•†"
              >
                {AI_PROVIDERS.map((provider) => (
                  <MenuItem key={provider.id} value={provider.id}>
                    {provider.name}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>

          {/* æ¨¡å‹é€‰æ‹© */}
          <Grid item xs={12} md={6}>
            <FormControl fullWidth>
              <InputLabel>AIæ¨¡å‹</InputLabel>
              <Select
                value={config.selectedModel}
                onChange={handleChange('selectedModel')}
                label="AIæ¨¡å‹"
              >
                {providerModels.map((model) => (
                  <MenuItem key={model.id} value={model.id}>
                    {model.name}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>

### å30é¡µæºä»£ç 

#### æ–‡ä»¶1: frontend/src/types/index.ts - ç±»å‹å®šä¹‰ç³»ç»Ÿï¼ˆå¼€å§‹éƒ¨åˆ†ï¼‰
```typescript
// åŸºç¡€ç±»å‹å®šä¹‰
export interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

// ç”¨æˆ·ç›¸å…³ç±»å‹
export interface User extends BaseEntity {
  username: string;
  email: string;
  displayName: string;
  role: UserRole;
  status: UserStatus;
  avatar?: string;
  lastLoginAt?: Date;
  metadata?: Record<string, any>;
}

export enum UserRole {
  ADMIN = 'admin',
  TEACHER = 'teacher',
  STUDENT = 'student',
  GUEST = 'guest'
}

export enum UserStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  SUSPENDED = 'suspended',
  PENDING = 'pending'
}

// å®éªŒç›¸å…³ç±»å‹
export interface Experiment extends BaseEntity {
  title: string;
  description: string;
  authorId: string;
  templateId?: string;
  status: ExperimentStatus;
  category: string;
  tags: string[];
  objectives: string[];
  instructions: ExperimentInstruction[];
  materials: ExperimentMaterial[];
  results: ExperimentResult[];
  visibility: ExperimentVisibility;
  featuredImageUrl?: string;
  estimatedDuration: number; // åˆ†é’Ÿ
  difficulty: ExperimentDifficulty;
  metadata?: Record<string, any>;
}

export interface ExperimentInstruction {
  step: number;
  title: string;
  content: string;
  imageUrls?: string[];
  videoUrl?: string;
  duration?: number; // ä¼°è®¡åˆ†é’Ÿæ•°
  note?: string;
}

export interface ExperimentMaterial {
  id: string;
  name: string;
  description?: string;
  quantity: number;
  unit?: string;
  type: MaterialType;
  imageUrl?: string;
  link?: string;
}

export enum MaterialType {
  EQUIPMENT = 'equipment',
  CHEMICAL = 'chemical',
  BIOLOGICAL = 'biological',
  TOOL = 'tool',
  OTHER = 'other'
}

export interface ExperimentResult {
  id: string;
  title: string;
  description: string;
  type: ResultType;
  data?: any;
  imageUrls?: string[];
  createdAt: Date;
  createdBy: string;
}

export enum ResultType {
  MEASUREMENT = 'measurement',
  OBSERVATION = 'observation',
  CALCULATION = 'calculation',
  CONCLUSION = 'conclusion'
}

export enum ExperimentStatus {
  DRAFT = 'draft',
  ACTIVE = 'active',
  ARCHIVED = 'archived',
  PENDING_REVIEW = 'pending_review',
  DELETED = 'deleted'
}

export enum ExperimentVisibility {
  PUBLIC = 'public',
  PRIVATE = 'private',
  ORGANIZATION = 'organization'
}

export enum ExperimentDifficulty {
  BEGINNER = 'beginner',
  INTERMEDIATE = 'intermediate',
  ADVANCED = 'advanced',
  EXPERT = 'expert'
}

// æ¨¡æ¿ç›¸å…³ç±»å‹
export interface ExperimentTemplate extends BaseEntity {
  title: string;
  description: string;
  authorId: string;
  category: string;
  tags: string[];
  featuredImageUrl?: string;
  structure: ExperimentTemplateStructure;
  popularity: number;
  usageCount: number;
  rating: number;
  visibility: ExperimentVisibility;
  metadata?: Record<string, any>;
}

export interface ExperimentTemplateStructure {
  instructions: ExperimentInstruction[];
  materials: ExperimentMaterial[];
  objectives: string[];
  estimatedDuration: number;
  difficulty: ExperimentDifficulty;
}

// AIåŠ©æ‰‹ç›¸å…³ç±»å‹
export interface ChatMessage {
  id: string;
  role: 'system' | 'user' | 'assistant';
  content: string;
  timestamp: Date;
  metadata?: Record<string, any>;
}

export interface ChatSession {
  id: string;
  userId: string;
  title: string;
  messages: ChatMessage[];
  modelId: string;
  createdAt: Date;
  updatedAt: Date;
  metadata?: Record<string, any>;
}

export interface AIAssistantResponse {
  content: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  model: string;
  finishReason?: string;
}

// è®¾å¤‡ç›¸å…³ç±»å‹
export interface Device extends BaseEntity {
  name: string;
  type: DeviceType;
  status: DeviceStatus;
  ipAddress?: string;
  location?: string;
  description?: string;
  specifications?: Record<string, any>;
  firmwareVersion?: string;
  lastMaintenance?: Date;
  nextMaintenance?: Date;
  ownerId: string;
  metadata?: Record<string, any>;
}

export enum DeviceType {
  SENSOR = 'sensor',
  CAMERA = 'camera',
  ACTUATOR = 'actuator',
  CONTROL_SYSTEM = 'control_system',
  MEASUREMENT = 'measurement',
  COMPUTER = 'computer',
  OTHER = 'other'
}

export enum DeviceStatus {
  ONLINE = 'online',
  OFFLINE = 'offline',
  MAINTENANCE = 'maintenance',
  ERROR = 'error',
  RESERVED = 'reserved'
}

export interface DeviceDataPoint {
  deviceId: string;
  timestamp: Date;
  value: number | string | boolean;
  type: string;
  unit?: string;
  metadata?: Record<string, any>;
}

export interface DeviceCommand {
  id: string;
  deviceId: string;
  command: string;
  parameters?: Record<string, any>;
  status: CommandStatus;
  createdAt: Date;
  executedAt?: Date;
  result?: Record<string, any>;
}

export enum CommandStatus {
  PENDING = 'pending',
  EXECUTING = 'executing',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELLED = 'cancelled'
}

export interface DeviceReservation {
  id: string;
  deviceId: string;
  userId: string;
  startTime: Date;
  endTime: Date;
  purpose: string;
  status: ReservationStatus;
  notes?: string;
}

export enum ReservationStatus {
  PENDING = 'pending',
  CONFIRMED = 'confirmed',
  CANCELLED = 'cancelled',
  COMPLETED = 'completed'
}

// æŸ¥è¯¢å‚æ•°ç±»å‹
export interface GetDevicesParams {
  type?: DeviceType;
  status?: DeviceStatus;
  location?: string;
  ownerId?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface GetDeviceDataParams {
  deviceId: string;
  startDate?: Date;
  endDate?: Date;
  type?: string;
  limit?: number;
  aggregation?: 'none' | 'hourly' | 'daily' | 'weekly';
}

export interface SendDeviceCommandParams {
  deviceId: string;
  command: string;
  parameters?: Record<string, any>;
  priority?: 'low' | 'normal' | 'high';
}

export interface CreateDeviceReservationParams {
  deviceId: string;
  startTime: Date;
  endTime: Date;
  purpose: string;
  notes?: string;
}

export interface GetDeviceReservationsParams {
  deviceId?: string;
  userId?: string;
  status?: ReservationStatus;
  startTime?: Date;
  endTime?: Date;
  page?: number;
  limit?: number;
}

export interface DeviceMonitoringData {
  deviceId: string;
  status: DeviceStatus;
  metrics: {
    cpu?: number;
    memory?: number;
    diskSpace?: number;
    temperature?: number;
    battery?: number;
  };
  lastHeartbeat: Date;
  alerts: Array<{
    type: string;
    message: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    timestamp: Date;
  }>;
}

#### æ–‡ä»¶2: backend/src/controllers/device.controller.ts - è®¾å¤‡æ§åˆ¶å™¨
```typescript
import { Request, Response } from 'express';
import { DeviceService } from '../services/device.service';
import { validateSchema } from '../middleware/validation';
import { DeviceSchema, DeviceQuerySchema } from '../schemas/device.schema';

export class DeviceController {
  private deviceService: DeviceService;

  constructor() {
    this.deviceService = new DeviceService();
  }

  /**
   * è·å–æ‰€æœ‰è®¾å¤‡
   */
  public getAllDevices = async (req: Request, res: Response): Promise<void> => {
    try {
      // éªŒè¯æŸ¥è¯¢å‚æ•°
      const validatedQuery = validateSchema(DeviceQuerySchema, req.query);
      
      // è·å–è®¾å¤‡
      const devices = await this.deviceService.getAllDevices(validatedQuery);
      
      res.status(200).json({
        success: true,
        data: devices,
        message: 'æˆåŠŸè·å–è®¾å¤‡åˆ—è¡¨',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || 'è·å–è®¾å¤‡åˆ—è¡¨å¤±è´¥',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * è·å–è®¾å¤‡è¯¦æƒ…
   */
  public getDeviceById = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      
      // è·å–è®¾å¤‡
      const device = await this.deviceService.getDeviceById(id);
      
      res.status(200).json({
        success: true,
        data: device,
        message: 'æˆåŠŸè·å–è®¾å¤‡è¯¦æƒ…',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || 'è·å–è®¾å¤‡è¯¦æƒ…å¤±è´¥',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * åˆ›å»ºè®¾å¤‡
   */
  public createDevice = async (req: Request, res: Response): Promise<void> => {
    try {
      // éªŒè¯è¯·æ±‚æ•°æ®
      const validatedData = validateSchema(DeviceSchema, req.body);
      
      // åˆ›å»ºè®¾å¤‡
      const device = await this.deviceService.createDevice({
        ...validatedData,
        ownerId: req.user.id // ä»è®¤è¯ä¸­é—´ä»¶è·å–ç”¨æˆ·ID
      });
      
      res.status(201).json({
        success: true,
        data: device,
        message: 'æˆåŠŸåˆ›å»ºè®¾å¤‡',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || 'åˆ›å»ºè®¾å¤‡å¤±è´¥',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * æ›´æ–°è®¾å¤‡
   */
  public updateDevice = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      
      // éªŒè¯è¯·æ±‚æ•°æ®
      const validatedData = validateSchema(DeviceSchema, req.body, { partial: true });
      
      // æ›´æ–°è®¾å¤‡
      const device = await this.deviceService.updateDevice(id, validatedData);
      
      res.status(200).json({
        success: true,
        data: device,
        message: 'æˆåŠŸæ›´æ–°è®¾å¤‡',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || 'æ›´æ–°è®¾å¤‡å¤±è´¥',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * åˆ é™¤è®¾å¤‡
   */
  public deleteDevice = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      
      // åˆ é™¤è®¾å¤‡
      await this.deviceService.deleteDevice(id);
      
      res.status(200).json({
        success: true,
        message: 'æˆåŠŸåˆ é™¤è®¾å¤‡',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || 'åˆ é™¤è®¾å¤‡å¤±è´¥',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * è·å–è®¾å¤‡æ•°æ®
   */
  public getDeviceData = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const { startDate, endDate, type, limit, aggregation } = req.query;
      
      // è·å–è®¾å¤‡æ•°æ®
      const data = await this.deviceService.getDeviceData({
        deviceId: id,
        startDate: startDate ? new Date(startDate as string) : undefined,
        endDate: endDate ? new Date(endDate as string) : undefined,
        type: type as string,
        limit: limit ? parseInt(limit as string) : undefined,
        aggregation: aggregation as 'none' | 'hourly' | 'daily' | 'weekly' | undefined
      });
      
      res.status(200).json({
        success: true,
        data,
        message: 'æˆåŠŸè·å–è®¾å¤‡æ•°æ®',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || 'è·å–è®¾å¤‡æ•°æ®å¤±è´¥',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * å‘é€è®¾å¤‡å‘½ä»¤
   */
  public sendCommand = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const { command, parameters, priority } = req.body;
      
      // å‘é€å‘½ä»¤
      const result = await this.deviceService.sendCommand({
        deviceId: id,
        command,
        parameters,
        priority
      });
      
      res.status(200).json({
        success: true,
        data: result,
        message: 'æˆåŠŸå‘é€è®¾å¤‡å‘½ä»¤',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || 'å‘é€è®¾å¤‡å‘½ä»¤å¤±è´¥',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * è·å–è®¾å¤‡ç›‘æ§æ•°æ®
   */
  public getMonitoringData = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      
      // è·å–ç›‘æ§æ•°æ®
      const data = await this.deviceService.getMonitoringData(id);
      
      res.status(200).json({
        success: true,
        data,
        message: 'æˆåŠŸè·å–è®¾å¤‡ç›‘æ§æ•°æ®',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || 'è·å–è®¾å¤‡ç›‘æ§æ•°æ®å¤±è´¥',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };
}

#### æ–‡ä»¶3: backend/src/controllers/template.controller.ts - æ¨¡æ¿æ§åˆ¶å™¨
```typescript
import { Request, Response } from 'express';
import { TemplateService } from '../services/template.service';
import { validateSchema } from '../middleware/validation';
import { TemplateSchema, TemplateQuerySchema } from '../schemas/template.schema';

export class TemplateController {
  private templateService: TemplateService;

  constructor() {
    this.templateService = new TemplateService();
  }

  /**
   * è·å–æ‰€æœ‰æ¨¡æ¿
   */
  public getAllTemplates = async (req: Request, res: Response): Promise<void> => {
    try {
      // éªŒè¯æŸ¥è¯¢å‚æ•°
      const validatedQuery = validateSchema(TemplateQuerySchema, req.query);
      
      // è·å–æ¨¡æ¿
      const templates = await this.templateService.getAllTemplates(validatedQuery);
      
      res.status(200).json({
        success: true,
        data: templates,
        message: 'æˆåŠŸè·å–æ¨¡æ¿åˆ—è¡¨',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || 'è·å–æ¨¡æ¿åˆ—è¡¨å¤±è´¥',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * è·å–æ¨¡æ¿è¯¦æƒ…
   */
  public getTemplateById = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      
      // è·å–æ¨¡æ¿
      const template = await this.templateService.getTemplateById(id);
      
      res.status(200).json({
        success: true,
        data: template,
        message: 'æˆåŠŸè·å–æ¨¡æ¿è¯¦æƒ…',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || 'è·å–æ¨¡æ¿è¯¦æƒ…å¤±è´¥',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * åˆ›å»ºæ¨¡æ¿
   */
  public createTemplate = async (req: Request, res: Response): Promise<void> => {
    try {
      // éªŒè¯è¯·æ±‚æ•°æ®
      const validatedData = validateSchema(TemplateSchema, req.body);
      
      // åˆ›å»ºæ¨¡æ¿
      const template = await this.templateService.createTemplate({
        ...validatedData,
        authorId: req.user.id // ä»è®¤è¯ä¸­é—´ä»¶è·å–ç”¨æˆ·ID
      });
      
      res.status(201).json({
        success: true,
        data: template,
        message: 'æˆåŠŸåˆ›å»ºæ¨¡æ¿',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || 'åˆ›å»ºæ¨¡æ¿å¤±è´¥',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * æ›´æ–°æ¨¡æ¿
   */
  public updateTemplate = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      
      // éªŒè¯è¯·æ±‚æ•°æ®
      const validatedData = validateSchema(TemplateSchema, req.body, { partial: true });
      
      // æ›´æ–°æ¨¡æ¿
      const template = await this.templateService.updateTemplate(id, validatedData);
      
      res.status(200).json({
        success: true,
        data: template,
        message: 'æˆåŠŸæ›´æ–°æ¨¡æ¿',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || 'æ›´æ–°æ¨¡æ¿å¤±è´¥',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * åˆ é™¤æ¨¡æ¿
   */
  public deleteTemplate = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      
      // åˆ é™¤æ¨¡æ¿
      await this.templateService.deleteTemplate(id);
      
      res.status(200).json({
        success: true,
        message: 'æˆåŠŸåˆ é™¤æ¨¡æ¿',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || 'åˆ é™¤æ¨¡æ¿å¤±è´¥',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * åŸºäºæ¨¡æ¿åˆ›å»ºå®éªŒ
   */
  public createExperimentFromTemplate = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const { title, description, customizations } = req.body;
      
      // åˆ›å»ºå®éªŒ
      const experiment = await this.templateService.createExperimentFromTemplate(id, {
        userId: req.user.id,
        title,
        description,
        customizations
      });
      
      res.status(201).json({
        success: true,
        data: experiment,
        message: 'æˆåŠŸåŸºäºæ¨¡æ¿åˆ›å»ºå®éªŒ',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || 'åŸºäºæ¨¡æ¿åˆ›å»ºå®éªŒå¤±è´¥',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * è·å–æ¨¡æ¿ä½¿ç”¨ç»Ÿè®¡æ•°æ®
   */
  public getTemplateStats = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      
      // è·å–ç»Ÿè®¡æ•°æ®
      const stats = await this.templateService.getTemplateStats(id);
      
      res.status(200).json({
        success: true,
        data: stats,
        message: 'æˆåŠŸè·å–æ¨¡æ¿ç»Ÿè®¡æ•°æ®',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || 'è·å–æ¨¡æ¿ç»Ÿè®¡æ•°æ®å¤±è´¥',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };
}

export default new TemplateController();
```

ä»¥ä¸Šä»£ç å±•ç¤ºäº†SSLAB-AIå®éªŒå¹³å°è½¯ä»¶çš„æ ¸å¿ƒéƒ¨åˆ†ï¼ŒåŒ…æ‹¬åç«¯æœåŠ¡å™¨é…ç½®ã€AIæœåŠ¡æ¨¡å—ã€å‰ç«¯åº”ç”¨æ¡†æ¶ã€APIæœåŠ¡å±‚ä»¥åŠç±»å‹å®šä¹‰ç³»ç»Ÿç­‰å…³é”®ç»„ä»¶ã€‚è¿™äº›ä»£ç å…±åŒæ„æˆäº†ä¸€ä¸ªå®Œæ•´çš„äººå·¥æ™ºèƒ½è¾…åŠ©å®éªŒå¹³å°ï¼Œæ”¯æŒå®éªŒè®¾è®¡ã€æ•°æ®åˆ†æã€è®¾å¤‡ç®¡ç†å’Œæ™ºèƒ½äº¤äº’ç­‰åŠŸèƒ½ã€‚å¹³å°é‡‡ç”¨TypeScriptå…¨æ ˆå¼€å‘ï¼Œä¿è¯äº†ç±»å‹å®‰å…¨å’Œä»£ç å¯ç»´æŠ¤æ€§ï¼Œå¹¶é€šè¿‡æ¨¡å—åŒ–æ¶æ„å®ç°äº†ç³»ç»Ÿçš„å¯æ‰©å±•æ€§ã€‚
      h3: {
        fontSize: '1.75rem',
        fontWeight: 600,
      },
      h4: {
        fontSize: '1.5rem',
        fontWeight: 600,
      },
      h5: {
        fontSize: '1.25rem',
        fontWeight: 600,
      },
      h6: {
        fontSize: '1rem',
        fontWeight: 600,
      },
    },
    components: {
      MuiButton: {
        styleOverrides: {
          root: {
            textTransform: 'none',
            borderRadius: 8,
          },
        },
      },
      MuiPaper: {
        styleOverrides: {
          root: {
            borderRadius: 12,
          },
        },
      },
    },
  });
  // æ£€æŸ¥ç”¨æˆ·è®¤è¯çŠ¶æ€
  useEffect(() => {
    const { isAuthenticated, fetchCurrentUser } = useUserStore.getState();
    const token = localStorage.getItem('token');

    if (token && !isAuthenticated) {
      // éªŒè¯tokenå¹¶è·å–ç”¨æˆ·ä¿¡æ¯
      fetchCurrentUser();
    }
  }, []);
  return (
    <ErrorBoundary FallbackComponent={ErrorFallback}>
      <HelmetProvider>
        <QueryClientProvider client={queryClient}>
          <ThemeProvider theme={theme}>
            <CssBaseline />
            <Toaster
                  position="top-right"
                  toastOptions={{
                    duration: 4000,
                    style: {
                      background: theme.palette.background.paper,
                      color: theme.palette.text.primary,
                      border: `1px solid ${theme.palette.divider}`,
                    },
                  }}
                />
                
                {/* PWAæç¤ºç»„ä»¶ */}
                <PWAPrompt autoShow={true} showNetworkStatus={true} />
                
                <Router future={{ v7_startTransition: true, v7_relativeSplatPath: true }}>
                  <Routes>
                    {/* å…¬å¼€è·¯ç”± */}
                    <Route path="/login" element={<Login />} />
                    <Route path="/register" element={<Register />} />
                    
                    {/* å—ä¿æŠ¤çš„è·¯ç”± */}
                    <Route
                      path="/*"
                      element={
                        <ProtectedRoute>
                          <MainLayout>
                            {/* åœ¨è¿™é‡ŒåµŒå¥—å…¶ä»–è·¯ç”± */}
                            <Routes>
                              <Route path="dashboard" element={<Dashboard />} />
                              <Route path="experiments" element={<ExperimentList />} />
                              <Route path="experiments/create" element={<ExperimentCreate />} />
                              <Route path="experiments/:id" element={<ExperimentDetail />} />
                              <Route path="templates" element={<TemplateLibrary />} />
                              <Route path="templates/create" element={<TemplateCreate />} />
                              <Route path="templates/:id" element={<TemplateDetail />} />
                              <Route path="devices" element={<DeviceManagement />} />
                              <Route path="resources" element={<ResourceManagement />} />
                              <Route path="data-collection" element={<DataCollectionAnalysis />} />
                              <Route path="ai-assistant" element={<AIAssistant />} />
                              <Route path="guidance" element={<GuidanceSystem />} />
                              <Route path="api-check" element={<ApiIntegrationCheck />} />
                              <Route path="settings" element={<Settings />} />
                              <Route path="help" element={<Help />} />
                              <Route path="templates" element={<TemplateLibrary />} />
                              <Route path="templates/create" element={<TemplateCreate />} />
                              <Route path="templates/:id" element={<TemplateDetail />} />
                              {/* é»˜è®¤é‡å®šå‘åˆ°dashboard */}
                              <Route index element={<Navigate to="/dashboard" />} />
                            </Routes>
                          </MainLayout>
                        </ProtectedRoute>
                      }
                    />
                  </Routes>
                </Router>
              </ThemeProvider>
        </QueryClientProvider>
      </HelmetProvider>
    </ErrorBoundary>
  );
};

export default App;
    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setLoading(true);
    
    try {
      const response = await apiService.sendAIMessage(input);
      
      const assistantMessage: AIMessage = {
        id: response.id,
        content: response.content,
        role: 'assistant',
        timestamp: new Date()
      };
      
      setMessages(prev => [...prev, assistantMessage]);
    } catch (error) {
      console.error('Failed to get AI response:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Paper sx={{ p: 2, height: '100%', display: 'flex', flexDirection: 'column' }}>
      <Typography variant="h6" gutterBottom>å®éªŒAIåŠ©æ‰‹</Typography>
      
      <Box sx={{ flexGrow: 1, overflow: 'auto', mb: 2 }}>
        {messages.map(message => (
          <Box 
            key={message.id}
            sx={{
              p: 1,
              mb: 1,
              borderRadius: 1,
              bgcolor: message.role === 'user' ? 'primary.light' : 'background.paper',
              alignSelf: message.role === 'user' ? 'flex-end' : 'flex-start',
              maxWidth: '80%'
            }}
          >
            <Typography variant="body1">{message.content}</Typography>
          </Box>
        ))}
        {loading && (
          <Box sx={{ display: 'flex', justifyContent: 'center' }}>
            <CircularProgress size={24} />
          </Box>
        )}
      </Box>
      
      <Box sx={{ display: 'flex' }}>
        <TextField
          fullWidth
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="è¾“å…¥æ‚¨çš„é—®é¢˜..."
          variant="outlined"
          size="small"
          onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
        />
        <Button 
          variant="contained" 
          color="primary" 
          onClick={handleSendMessage}
          disabled={loading || !input.trim()}
          sx={{ ml: 1 }}
        >
          å‘é€
        </Button>
      </Box>
    </Paper>
  );
};

export default AIAssistant;
```

### åç«¯æœåŠ¡ç¤ºä¾‹ï¼ˆNode.js/TypeScriptï¼‰
```typescript
// AIåŠ©æ‰‹æœåŠ¡ç¤ºä¾‹
import { Request, Response } from 'express';
import { AIModelType, AICompletionOptions } from '../types';
import logger from '../utils/logger';
import { getModelConfig } from '../config/ai-models';

export class AIAssistantService {
  /**
   * å¤„ç†AIå¯¹è¯è¯·æ±‚
   * @param modelType AIæ¨¡å‹ç±»å‹
   * @param message ç”¨æˆ·æ¶ˆæ¯
   * @param options è¡¥å…¨é€‰é¡¹
   * @returns AIå“åº”
   */
  async processAIMessage(modelType: AIModelType, message: string, options?: AICompletionOptions) {
    try {
      logger.info(`Processing AI message with model: ${modelType}`);
      
      // è·å–æ¨¡å‹é…ç½®
      const modelConfig = getModelConfig(modelType);
      if (!modelConfig) {
        throw new Error(`Model configuration not found for: ${modelType}`);
      }
      
      // å‡†å¤‡è¯·æ±‚å‚æ•°
      const requestParams = {
        model: modelConfig.modelId,
        messages: [{ role: 'user', content: message }],
        temperature: options?.temperature || modelConfig.defaultTemperature,
        max_tokens: options?.maxTokens || modelConfig.outputTokenLimit,
        // å…¶ä»–å‚æ•°...
      };
      
      // è°ƒç”¨AIæ¨¡å‹API
      const response = await this.callModelAPI(modelType, requestParams);
      
      return {
        id: response.id,
        content: response.choices[0].message.content,
        model: modelType,
        usage: response.usage
      };
    } catch (error) {
      logger.error('Error processing AI message:', error);
      throw error;
    }
  }
  
  /**
   * è°ƒç”¨ä¸åŒAIæ¨¡å‹çš„API
   * @param modelType æ¨¡å‹ç±»å‹
   * @param params è¯·æ±‚å‚æ•°
   * @returns APIå“åº”
   */
  private async callModelAPI(modelType: AIModelType, params: any) {
    // æ ¹æ®ä¸åŒæ¨¡å‹ç±»å‹è°ƒç”¨ä¸åŒAPI
    switch (modelType) {
      case 'doubao':
        return this.callDoubaoAPI(params);
      case 'deepseek':
        return this.callDeepseekAPI(params);
      default:
        throw new Error(`Unsupported model type: ${modelType}`);
    }
  }
  
  // å…·ä½“æ¨¡å‹APIè°ƒç”¨æ–¹æ³•...
}

export default new AIAssistantService();
```

## è½¯ä»¶åˆ›æ–°ç‚¹ä¸ç¤¾ä¼šæ„ä¹‰

### åˆ›æ–°ç‚¹
1. å¤šæ¨¡å‹æ™ºèƒ½è°ƒåº¦æŠ€æœ¯ï¼Œæé«˜AIè¾…åŠ©å®éªŒçš„é’ˆå¯¹æ€§å’Œæ•ˆç‡
2. å®éªŒå…¨ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼Œå®ç°æ•™å­¦å®éªŒçš„æ•°å­—åŒ–ã€æ™ºèƒ½åŒ–
3. æ•™è‚²åœºæ™¯ä¼˜åŒ–çš„äººæœºäº¤äº’ï¼Œé™ä½AIæŠ€æœ¯åœ¨æ•™è‚²ä¸­çš„åº”ç”¨é—¨æ§›
4. åˆ†å¸ƒå¼å®éªŒèµ„æºç®¡ç†ï¼Œæé«˜å®éªŒè®¾å¤‡åˆ©ç”¨ç‡
5. æ•™è‚²æ•°æ®çš„å®‰å…¨ä¸éšç§ä¿æŠ¤æœºåˆ¶åˆ›æ–°

### ç¤¾ä¼šæ„ä¹‰
1. ä¿ƒè¿›æ•™è‚²å…¬å¹³ï¼šé€šè¿‡AIè¾…åŠ©ï¼Œç¼©å°ä¸åŒåœ°åŒºã€ä¸åŒå­¦æ ¡é—´çš„æ•™è‚²èµ„æºå·®è·
2. æå‡æ•™è‚²è´¨é‡ï¼šä¸ªæ€§åŒ–å®éªŒæŒ‡å¯¼æé«˜å­¦ä¹ æ•ˆæœï¼ŒåŸ¹å…»åˆ›æ–°èƒ½åŠ›
3. ä¼˜åŒ–æ•™è‚²èµ„æºï¼šæé«˜å®éªŒè®¾å¤‡åˆ©ç”¨ç‡ï¼Œé™ä½æ•™è‚²æˆæœ¬
4. åŸ¹å…»æœªæ¥äººæ‰ï¼šè®­ç»ƒå­¦ç”Ÿä½¿ç”¨AIå·¥å…·çš„èƒ½åŠ›ï¼Œé€‚åº”æ™ºèƒ½åŒ–æœªæ¥
5. æ¨åŠ¨æ•™è‚²åˆ›æ–°ï¼šæ¢ç´¢AIä¸æ•™è‚²æ·±åº¦èåˆçš„æ–°æ¨¡å¼ï¼Œå¼•é¢†æ•™è‚²å˜é©

# è½¯è‘—ç™»è®°æ ¸å¿ƒæºä»£ç 

## 1. å‰ç«¯åº”ç”¨ä¸»å…¥å£ (frontend/src/index.tsx)

```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from 'react-query';
import { ReactQueryDevtools } from 'react-query/devtools';
import { ThemeProvider, createTheme, CssBaseline } from '@mui/material';
import { Toaster } from 'react-hot-toast';
import App from './App';
import { FeatureFlagsProvider, EditionType } from './features/featureFlags';
import { LicensingProvider } from './features/licensing';
import './index.css';

// åˆ›å»ºReact Queryå®¢æˆ·ç«¯
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 3,
      retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
      staleTime: 5 * 60 * 1000, // 5åˆ†é’Ÿ
      cacheTime: 10 * 60 * 1000, // 10åˆ†é’Ÿ
      refetchOnWindowFocus: false,
    },
    mutations: {
      retry: 1,
    },
  },
});

// åˆ›å»ºä¸»é¢˜
const theme = createTheme({
  palette: {
    mode: 'light',
    primary: {
      main: '#1976d2',
      light: '#42a5f5',
      dark: '#1565c0',
    },
    secondary: {
      main: '#dc004e',
      light: '#ff5983',
      dark: '#9a0036',
    },
    background: {
      default: '#f5f5f5',
      paper: '#ffffff',
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h4: {
      fontWeight: 600,
    },
    h5: {
      fontWeight: 500,
    },
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          borderRadius: 8,
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          borderRadius: 0,
        },
      },
    },
  },
});

// ä»ç¯å¢ƒå˜é‡è·å–ç‰ˆæœ¬ï¼Œé»˜è®¤ä¸ºbasic
const editionFromEnv = (process.env.REACT_APP_EDITION as EditionType) || 'basic';

// é”™è¯¯è¾¹ç•Œç»„ä»¶
class ErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean; error?: Error }
> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('React Error Boundary caught an error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div style={{ 
          padding: '20px', 
          textAlign: 'center',
          minHeight: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          flexDirection: 'column'
        }}>
          <h1>åº”ç”¨é‡åˆ°é”™è¯¯</h1>
          <p>è¯·åˆ·æ–°é¡µé¢é‡è¯•ï¼Œå¦‚æœé—®é¢˜æŒç»­å­˜åœ¨ï¼Œè¯·è”ç³»æŠ€æœ¯æ”¯æŒã€‚</p>
          <button 
            onClick={() => window.location.reload()}
            style={{
              padding: '10px 20px',
              backgroundColor: '#1976d2',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer'
            }}
          >
            åˆ·æ–°é¡µé¢
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// åˆ›å»ºæ ¹å…ƒç´ 
const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

// æ¸²æŸ“åº”ç”¨
root.render(
  <React.StrictMode>
    <ErrorBoundary>
      <QueryClientProvider client={queryClient}>
        <BrowserRouter>
          <ThemeProvider theme={theme}>
            <CssBaseline />
            <LicensingProvider>
              <FeatureFlagsProvider initialEdition={editionFromEnv}>
                <App />
                <Toaster
                  position="top-right"
                  toastOptions={{
                    duration: 4000,
                    style: {
                      background: '#363636',
                      color: '#fff',
                    },
                    success: {
                      duration: 3000,
                      iconTheme: {
                        primary: '#4caf50',
                        secondary: '#fff',
                      },
                    },
                    error: {
                      duration: 5000,
                      iconTheme: {
                        primary: '#f44336',
                        secondary: '#fff',
                      },
                    },
                  }}
                />
              </FeatureFlagsProvider>
            </LicensingProvider>
          </ThemeProvider>
        </BrowserRouter>
        {process.env.NODE_ENV === 'development' && <ReactQueryDevtools />}
      </QueryClientProvider>
    </ErrorBoundary>
  </React.StrictMode>
);

// PWAæ”¯æŒ
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('SW registered: ', registration);
      })
      .catch((registrationError) => {
        console.log('SW registration failed: ', registrationError);
      });
  });
}

// æ€§èƒ½ç›‘æ§
const reportWebVitals = (metric: any) => {
  if (process.env.NODE_ENV === 'production') {
    // è¿™é‡Œå¯ä»¥å‘é€åˆ°åˆ†ææœåŠ¡
    console.log(metric);
  }
};

// å¯ç”¨æ€§èƒ½ç›‘æ§
if (process.env.NODE_ENV === 'production') {
  import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
    getCLS(reportWebVitals);
    getFID(reportWebVitals);
    getFCP(reportWebVitals);
    getLCP(reportWebVitals);
    getTTFB(reportWebVitals);
  });
}

export default App;
```

## 2. å‰ç«¯ä¸»åº”ç”¨ç»„ä»¶ (frontend/src/App.tsx)

```tsx
import React, { useEffect, useState } from 'react';
import { Routes, Route, Navigate, useLocation } from 'react-router-dom';
import { Box, Container, CircularProgress, Alert, Snackbar } from '@mui/material';
import { useUserStore } from './store';
import { useFeatureFlags } from './features/featureFlags';
import { useLicensing } from './features/licensing';

// å¸ƒå±€ç»„ä»¶
import Layout from './components/layout/Layout';
import PublicLayout from './components/layout/PublicLayout';

// é¡µé¢ç»„ä»¶
import Dashboard from './pages/Dashboard';
import TeacherDashboard from './pages/TeacherDashboard';
import ExperimentList from './pages/experiments/ExperimentList';
import ExperimentCreate from './pages/experiments/ExperimentCreate';
import ExperimentDetail from './pages/experiments/ExperimentDetail';
import TemplateLibrary from './pages/templates/TemplateLibrary';
import TemplateDetail from './pages/templates/TemplateDetail';
import ResourceManagement from './pages/resources/ResourceManagement';
import GuidanceSystem from './pages/guidance/GuidanceSystem';
import Settings from './pages/Settings';
import AIModelSettings from './pages/settings/AIModelSettings';
import Login from './pages/Login';
import Register from './pages/Register';
import Help from './pages/Help';
import NotFound from './pages/NotFound';

// AIåŠ©æ‰‹ç»„ä»¶
import AIAssistant from './components/ai/AIAssistant';

// æƒé™å®ˆå«ç»„ä»¶
interface ProtectedRouteProps {
  children: React.ReactNode;
  requireAuth?: boolean;
  requiredRole?: 'student' | 'teacher' | 'admin';
  requiredFeature?: string;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ 
  children, 
  requireAuth = true, 
  requiredRole,
  requiredFeature 
}) => {
  const { isAuthenticated, user } = useUserStore();
  const { isFeatureEnabled } = useFeatureFlags();
  const { isLicenseValid } = useLicensing();

  // æ£€æŸ¥è®¤è¯çŠ¶æ€
  if (requireAuth && !isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  // æ£€æŸ¥ç”¨æˆ·è§’è‰²
  if (requiredRole && user?.role !== requiredRole) {
    return <Navigate to="/dashboard" replace />;
  }

  // æ£€æŸ¥åŠŸèƒ½æƒé™
  if (requiredFeature && !isFeatureEnabled(requiredFeature)) {
    return (
      <Alert severity="warning" sx={{ m: 2 }}>
        æ­¤åŠŸèƒ½åœ¨å½“å‰ç‰ˆæœ¬ä¸­ä¸å¯ç”¨ï¼Œè¯·å‡çº§åˆ°æ›´é«˜ç‰ˆæœ¬ã€‚
      </Alert>
    );
  }

  // æ£€æŸ¥è®¸å¯è¯
  if (!isLicenseValid()) {
    return (
      <Alert severity="error" sx={{ m: 2 }}>
        è®¸å¯è¯å·²è¿‡æœŸï¼Œè¯·è”ç³»ç®¡ç†å‘˜ç»­è´¹ã€‚
      </Alert>
    );
  }

  return <>{children}</>;
};

// åŠ è½½ç»„ä»¶
const LoadingScreen: React.FC = () => (
  <Box
    display="flex"
    justifyContent="center"
    alignItems="center"
    minHeight="100vh"
    flexDirection="column"
  >
    <CircularProgress size={60} />
    <Box mt={2}>æ­£åœ¨åŠ è½½åº”ç”¨...</Box>
  </Box>
);

// ä¸»åº”ç”¨ç»„ä»¶
const App: React.FC = () => {
  const location = useLocation();
  const { 
    isAuthenticated, 
    user, 
    isLoading: userLoading, 
    fetchCurrentUser,
    error: userError 
  } = useUserStore();
  const { isFeatureEnabled } = useFeatureFlags();
  const [appLoading, setAppLoading] = useState(true);
  const [notification, setNotification] = useState<{
    open: boolean;
    message: string;
    severity: 'success' | 'error' | 'warning' | 'info';
  }>({ open: false, message: '', severity: 'info' });

  // åˆå§‹åŒ–åº”ç”¨
  useEffect(() => {
    const initializeApp = async () => {
      try {
        // æ£€æŸ¥æ˜¯å¦æœ‰å­˜å‚¨çš„è®¤è¯ä¿¡æ¯
        const token = localStorage.getItem('token');
        if (token) {
          await fetchCurrentUser();
        }
      } catch (error) {
        console.error('App initialization error:', error);
        setNotification({
          open: true,
          message: 'åº”ç”¨åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•',
          severity: 'error'
        });
      } finally {
        setAppLoading(false);
      }
    };

    initializeApp();
  }, [fetchCurrentUser]);

  // è·¯ç”±å˜åŒ–æ—¶çš„å¤„ç†
  useEffect(() => {
    // é¡µé¢è®¿é—®ç»Ÿè®¡
    if (process.env.NODE_ENV === 'production') {
      // è¿™é‡Œå¯ä»¥å‘é€é¡µé¢è®¿é—®ç»Ÿè®¡
      console.log('Page view:', location.pathname);
    }
  }, [location.pathname]);

  // å¤„ç†å…¨å±€é”™è¯¯
  useEffect(() => {
    if (userError) {
      setNotification({
        open: true,
        message: userError,
        severity: 'error'
      });
    }
  }, [userError]);

  // é”®ç›˜å¿«æ·é”®å¤„ç†
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Ctrl/Cmd + K æ‰“å¼€æœç´¢
      if ((event.ctrlKey || event.metaKey) && event.key === 'k') {
        event.preventDefault();
        // æ‰“å¼€æœç´¢åŠŸèƒ½
        console.log('Open search');
      }
      
      // Ctrl/Cmd + / æ‰“å¼€å¸®åŠ©
      if ((event.ctrlKey || event.metaKey) && event.key === '/') {
        event.preventDefault();
        // æ‰“å¼€å¸®åŠ©
        console.log('Open help');
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, []);

  // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
  if (appLoading || userLoading) {
    return <LoadingScreen />;
  }

  // å…¬å…±é¡µé¢è·¯ç”±ï¼ˆä¸éœ€è¦è®¤è¯ï¼‰
  const publicRoutes = ['/login', '/register', '/help'];
  const isPublicRoute = publicRoutes.includes(location.pathname);

  return (
    <>
      {/* è·¯ç”±é…ç½® */}
      <Routes>
        {/* å…¬å…±è·¯ç”± */}
        <Route path="/login" element={
          <PublicLayout>
            <Login />
          </PublicLayout>
        } />
        <Route path="/register" element={
          <PublicLayout>
            <Register />
          </PublicLayout>
        } />
        <Route path="/help" element={
          <PublicLayout>
            <Help />
          </PublicLayout>
        } />

        {/* å—ä¿æŠ¤çš„è·¯ç”± */}
        <Route path="/" element={
          <ProtectedRoute>
            <Layout>
              <Navigate to="/dashboard" replace />
            </Layout>
          </ProtectedRoute>
        } />
        
        <Route path="/dashboard" element={
          <ProtectedRoute>
            <Layout>
              {user?.role === 'teacher' ? <TeacherDashboard /> : <Dashboard />}
            </Layout>
          </ProtectedRoute>
        } />

        {/* å®éªŒç›¸å…³è·¯ç”± */}
        <Route path="/experiments" element={
          <ProtectedRoute>
            <Layout>
              <ExperimentList />
            </Layout>
          </ProtectedRoute>
        } />
        <Route path="/experiments/create" element={
          <ProtectedRoute>
            <Layout>
              <ExperimentCreate />
            </Layout>
          </ProtectedRoute>
        } />
        <Route path="/experiments/:id" element={
          <ProtectedRoute>
            <Layout>
              <ExperimentDetail />
            </Layout>
          </ProtectedRoute>
        } />

        {/* æ¨¡æ¿ç›¸å…³è·¯ç”± */}
        <Route path="/templates" element={
          <ProtectedRoute requiredFeature="templates">
            <Layout>
              <TemplateLibrary />
            </Layout>
          </ProtectedRoute>
        } />
        <Route path="/templates/:id" element={
          <ProtectedRoute requiredFeature="templates">
            <Layout>
              <TemplateDetail />
            </Layout>
          </ProtectedRoute>
        } />

        {/* èµ„æºç®¡ç†è·¯ç”± */}
        <Route path="/resources" element={
          <ProtectedRoute requiredRole="teacher">
            <Layout>
              <ResourceManagement />
            </Layout>
          </ProtectedRoute>
        } />

        {/* æŒ‡å¯¼ç³»ç»Ÿè·¯ç”± */}
        <Route path="/guidance" element={
          <ProtectedRoute requiredFeature="aiGuidance">
            <Layout>
              <GuidanceSystem />
            </Layout>
          </ProtectedRoute>
        } />

        {/* è®¾ç½®ç›¸å…³è·¯ç”± */}
        <Route path="/settings" element={
          <ProtectedRoute>
            <Layout>
              <Settings />
            </Layout>
          </ProtectedRoute>
        } />
        <Route path="/settings/ai-models" element={
          <ProtectedRoute requiredRole="admin">
            <Layout>
              <AIModelSettings />
            </Layout>
          </ProtectedRoute>
        } />

        {/* 404é¡µé¢ */}
        <Route path="*" element={<NotFound />} />
      </Routes>

      {/* AIåŠ©æ‰‹ï¼ˆä»…åœ¨å·²è®¤è¯ä¸”åŠŸèƒ½å¯ç”¨æ—¶æ˜¾ç¤ºï¼‰ */}
      {isAuthenticated && !isPublicRoute && isFeatureEnabled('aiAssistant') && (
        <AIAssistant />
      )}

      {/* å…¨å±€é€šçŸ¥ */}
      <Snackbar
        open={notification.open}
        autoHideDuration={6000}
        onClose={() => setNotification(prev => ({ ...prev, open: false }))}
        anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
      >
        <Alert 
          severity={notification.severity} 
          onClose={() => setNotification(prev => ({ ...prev, open: false }))}
        >
          {notification.message}
        </Alert>
      </Snackbar>
    </>
  );
};

export default App;
```

## 3. å‰ç«¯APIæœåŠ¡å±‚ (frontend/src/services/api.ts)

```typescript
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { toast } from 'react-hot-toast';

// APIå“åº”ç±»å‹å®šä¹‰
export interface ApiResponse<T = any> {
  data: T;
  message: string;
  success: boolean;
  code: number;
  timestamp: string;
}

// åˆ†é¡µå“åº”ç±»å‹
export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// APIé”™è¯¯ç±»å‹
export interface ApiError {
  message: string;
  code: number;
  details?: any;
}

// è¯·æ±‚æ‹¦æˆªå™¨é…ç½®
interface RequestInterceptorConfig {
  onRequest?: (config: AxiosRequestConfig) => AxiosRequestConfig;
  onRequestError?: (error: any) => Promise<any>;
}

// å“åº”æ‹¦æˆªå™¨é…ç½®
interface ResponseInterceptorConfig {
  onResponse?: (response: AxiosResponse) => AxiosResponse;
  onResponseError?: (error: any) => Promise<any>;
}

// APIæœåŠ¡ç±»
class ApiService {
  private client: AxiosInstance;
  private baseURL: string;
  private timeout: number = 30000;
  private retryAttempts: number = 3;
  private retryDelay: number = 1000;

  constructor() {
    // æ ¹æ®ç¯å¢ƒç¡®å®šAPIåŸºç¡€URL
    this.baseURL = this.getBaseURL();
    
    // åˆ›å»ºAxioså®ä¾‹
    this.client = axios.create({
      baseURL: this.baseURL,
      timeout: this.timeout,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    });

    // è®¾ç½®æ‹¦æˆªå™¨
    this.setupInterceptors();
  }

  /**
   * è·å–APIåŸºç¡€URL
   */
  private getBaseURL(): string {
    if (process.env.NODE_ENV === 'development') {
      return process.env.REACT_APP_API_URL || 'http://localhost:3001/api';
    }
    
    if (process.env.NODE_ENV === 'production') {
      return process.env.REACT_APP_API_URL || '/api';
    }
    
    return '/api';
  }

  /**
   * è®¾ç½®è¯·æ±‚å’Œå“åº”æ‹¦æˆªå™¨
   */
  private setupInterceptors(): void {
    // è¯·æ±‚æ‹¦æˆªå™¨
    this.client.interceptors.request.use(
      (config) => {
        // æ·»åŠ è®¤è¯token
        const token = localStorage.getItem('token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }

        // æ·»åŠ è¯·æ±‚IDç”¨äºè¿½è¸ª
        config.headers['X-Request-ID'] = this.generateRequestId();

        // æ·»åŠ æ—¶é—´æˆ³
        config.headers['X-Timestamp'] = Date.now().toString();

        // è®°å½•è¯·æ±‚æ—¥å¿—
        if (process.env.NODE_ENV === 'development') {
          console.log('ğŸš€ API Request:', {
            method: config.method?.toUpperCase(),
            url: config.url,
            data: config.data,
            params: config.params,
          });
        }

        return config;
      },
      (error) => {
        console.error('âŒ Request Error:', error);
        return Promise.reject(error);
      }
    );

    // å“åº”æ‹¦æˆªå™¨
    this.client.interceptors.response.use(
      (response) => {
        // è®°å½•å“åº”æ—¥å¿—
        if (process.env.NODE_ENV === 'development') {
          console.log('âœ… API Response:', {
            status: response.status,
            url: response.config.url,
            data: response.data,
          });
        }

        return response;
      },
      async (error) => {
        const originalRequest = error.config;

        // è®°å½•é”™è¯¯æ—¥å¿—
        console.error('âŒ API Error:', {
          status: error.response?.status,
          url: error.config?.url,
          message: error.response?.data?.message || error.message,
        });

        // å¤„ç†401æœªæˆæƒé”™è¯¯
        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true;
          
          // æ¸…é™¤æœ¬åœ°å­˜å‚¨çš„token
          localStorage.removeItem('token');
          
          // é‡å®šå‘åˆ°ç™»å½•é¡µé¢
          if (window.location.pathname !== '/login') {
            window.location.href = '/login';
          }
          
          return Promise.reject(error);
        }

        // å¤„ç†403æƒé™é”™è¯¯
        if (error.response?.status === 403) {
          toast.error('æ‚¨æ²¡æœ‰æ‰§è¡Œæ­¤æ“ä½œçš„æƒé™');
          return Promise.reject(error);
        }

        // å¤„ç†404é”™è¯¯
        if (error.response?.status === 404) {
          toast.error('è¯·æ±‚çš„èµ„æºä¸å­˜åœ¨');
          return Promise.reject(error);
        }

        // å¤„ç†500æœåŠ¡å™¨é”™è¯¯
        if (error.response?.status >= 500) {
          toast.error('æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•');
          return Promise.reject(error);
        }

        // å¤„ç†ç½‘ç»œé”™è¯¯
        if (!error.response) {
          toast.error('ç½‘ç»œè¿æ¥é”™è¯¯ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®');
          return Promise.reject(error);
        }

        // å¤„ç†è¶…æ—¶é”™è¯¯
        if (error.code === 'ECONNABORTED') {
          toast.error('è¯·æ±‚è¶…æ—¶ï¼Œè¯·é‡è¯•');
          return Promise.reject(error);
        }

        // è‡ªåŠ¨é‡è¯•æœºåˆ¶
        if (originalRequest._retryCount < this.retryAttempts) {
          originalRequest._retryCount = originalRequest._retryCount || 0;
          originalRequest._retryCount++;

          await this.delay(this.retryDelay * originalRequest._retryCount);
          return this.client(originalRequest);
        }

        return Promise.reject(error);
      }
    );
  }

  /**
   * ç”Ÿæˆè¯·æ±‚ID
   */
  private generateRequestId(): string {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * å»¶è¿Ÿå‡½æ•°
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * GETè¯·æ±‚
   */
  async get<T = any>(url: string, params?: any, config?: AxiosRequestConfig): Promise<T> {
    try {
      const response = await this.client.get<ApiResponse<T>>(url, { 
        params, 
        ...config 
      });
      return response.data.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  /**
   * POSTè¯·æ±‚
   */
  async post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    try {
      const response = await this.client.post<ApiResponse<T>>(url, data, config);
      return response.data.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  /**
   * PUTè¯·æ±‚
   */
  async put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    try {
      const response = await this.client.put<ApiResponse<T>>(url, data, config);
      return response.data.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  /**
   * DELETEè¯·æ±‚
   */
  async delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {
    try {
      const response = await this.client.delete<ApiResponse<T>>(url, config);
      return response.data.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  /**
   * PATCHè¯·æ±‚
   */
  async patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    try {
      const response = await this.client.patch<ApiResponse<T>>(url, data, config);
      return response.data.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  /**
   * æ–‡ä»¶ä¸Šä¼ 
   */
  async upload<T = any>(url: string, file: File, onProgress?: (progress: number) => void): Promise<T> {
    const formData = new FormData();
    formData.append('file', file);

    try {
      const response = await this.client.post<ApiResponse<T>>(url, formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
        onUploadProgress: (progressEvent) => {
          if (onProgress && progressEvent.total) {
            const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);
            onProgress(progress);
          }
        },
      });
      return response.data.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  /**
   * ä¸‹è½½æ–‡ä»¶
   */
  async download(url: string, filename?: string): Promise<void> {
    try {
      const response = await this.client.get(url, {
        responseType: 'blob',
      });

      // åˆ›å»ºä¸‹è½½é“¾æ¥
      const downloadUrl = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = downloadUrl;
      link.download = filename || 'download';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(downloadUrl);
    } catch (error) {
      throw this.handleError(error);
    }
  }

  /**
   * é”™è¯¯å¤„ç†
   */
  private handleError(error: any): ApiError {
    if (error.response) {
      // æœåŠ¡å™¨å“åº”é”™è¯¯
      return {
        message: error.response.data?.message || 'æœåŠ¡å™¨é”™è¯¯',
        code: error.response.status,
        details: error.response.data,
      };
    } else if (error.request) {
      // ç½‘ç»œé”™è¯¯
      return {
        message: 'ç½‘ç»œè¿æ¥å¤±è´¥',
        code: 0,
        details: error.request,
      };
    } else {
      // å…¶ä»–é”™è¯¯
      return {
        message: error.message || 'æœªçŸ¥é”™è¯¯',
        code: -1,
        details: error,
      };
    }
  }

  /**
   * å–æ¶ˆè¯·æ±‚
   */
  createCancelToken() {
    return axios.CancelToken.source();
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºå–æ¶ˆè¯·æ±‚
   */
  isCancel(error: any): boolean {
    return axios.isCancel(error);
  }

  // === ä¸šåŠ¡APIæ–¹æ³• ===

  /**
   * ç”¨æˆ·è®¤è¯ç›¸å…³API
   */
  async login(email: string, password: string) {
    return this.post('/auth/login', { email, password });
  }

  async register(userData: any) {
    return this.post('/auth/register', userData);
  }

  async logout() {
    return this.post('/auth/logout');
  }

  async getCurrentUser() {
    return this.get('/auth/me');
  }

  async refreshToken() {
    return this.post('/auth/refresh');
  }

  /**
   * å®éªŒç›¸å…³API
   */
  async getExperiments(params?: any) {
    return this.get('/experiments', params);
  }

  async getExperiment(id: string) {
    return this.get(`/experiments/${id}`);
  }

  async createExperiment(data: any) {
    return this.post('/experiments', data);
  }

  async updateExperiment(id: string, data: any) {
    return this.put(`/experiments/${id}`, data);
  }

  async deleteExperiment(id: string) {
    return this.delete(`/experiments/${id}`);
  }

  async startExperiment(id: string) {
    return this.post(`/experiments/${id}/start`);
  }

  async stopExperiment(id: string) {
    return this.post(`/experiments/${id}/stop`);
  }

  /**
   * AIåŠ©æ‰‹ç›¸å…³API
   */
  async sendAIMessage(message: string, sessionId?: string) {
    return this.post('/ai/chat', { message, sessionId });
  }

  async getAIChatHistory(sessionId: string) {
    return this.get(`/ai/chat/${sessionId}/history`);
  }

  async createAISession() {
    return this.post('/ai/chat/session');
  }

  /**
   * æ¨¡æ¿ç›¸å…³API
   */
  async getTemplates(params?: any) {
    return this.get('/templates', params);
  }

  async getTemplate(id: string) {
    return this.get(`/templates/${id}`);
  }

  /**
   * æŒ‡å¯¼å»ºè®®ç›¸å…³API
   */
  async getGuidanceSuggestions(params?: any) {
    return this.get('/guidance/suggestions', params);
  }

  async createGuidanceSuggestion(data: any) {
    return this.post('/guidance/suggestions', data);
  }

  async getGuidanceSessionHistory(sessionId: string) {
    return this.get(`/guidance/sessions/${sessionId}`);
  }
}

// åˆ›å»ºå¹¶å¯¼å‡ºAPIæœåŠ¡å®ä¾‹
const apiService = new ApiService();
export default apiService;
```

## 4. åç«¯ä¸»æœåŠ¡å™¨ (backend/src/server.ts)

```typescript
import express, { Express, Request, Response, NextFunction } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import rateLimit from 'express-rate-limit';
import morgan from 'morgan';
import path from 'path';
import fs from 'fs';
import { createServer } from 'http';
import { Server as SocketIOServer } from 'socket.io';
import swaggerUi from 'swagger-ui-express';
import swaggerJsdoc from 'swagger-jsdoc';

// è·¯ç”±å¯¼å…¥
import authRoutes from './routes/auth.routes';
import experimentRoutes from './routes/experiment.routes';
import templateRoutes from './routes/template.routes';
import guidanceRoutes from './routes/guidance.routes';
import deviceRoutes from './routes/device.routes';
import aiRoutes from './routes/ai.routes';
import userRoutes from './routes/user.routes';
import uploadRoutes from './routes/upload.routes';

// ä¸­é—´ä»¶å¯¼å…¥
import { errorHandler } from './middleware/errorHandler';
import { requestLogger } from './middleware/requestLogger';
import { authMiddleware } from './middleware/auth';
import { validateRequest } from './middleware/validation';

// å·¥å…·å¯¼å…¥
import logger from './utils/logger';
import { connectDatabase } from './utils/database';
import { initializeRedis } from './utils/redis';
import { setupWebSocket } from './utils/websocket';

// ç±»å‹å®šä¹‰
interface ServerConfig {
  port: number;
  host: string;
  environment: string;
  corsOrigins: string[];
  rateLimitWindowMs: number;
  rateLimitMax: number;
  jwtSecret: string;
  databaseUrl: string;
  redisUrl: string;
}

// ç¯å¢ƒå˜é‡é…ç½®
const config: ServerConfig = {
  port: parseInt(process.env.PORT || '3001', 10),
  host: process.env.HOST || '0.0.0.0',
  environment: process.env.NODE_ENV || 'development',
  corsOrigins: process.env.CORS_ORIGINS?.split(',') || ['http://localhost:3000'],
  rateLimitWindowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS || '900000', 10), // 15åˆ†é’Ÿ
  rateLimitMax: parseInt(process.env.RATE_LIMIT_MAX || '100', 10), // æ¯ä¸ªIP 100æ¬¡è¯·æ±‚
  jwtSecret: process.env.JWT_SECRET || 'your-secret-key',
  databaseUrl: process.env.DATABASE_URL || 'mongodb://localhost:27017/aicam',
  redisUrl: process.env.REDIS_URL || 'redis://localhost:6379',
};

// Swaggeré…ç½®
const swaggerOptions = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'SSLAB-AIå®éªŒå¹³å° API',
      version: '1.0.0',
      description: 'äººå·¥æ™ºèƒ½è¾…åŠ©å®éªŒå¹³å°åç«¯APIæ–‡æ¡£',
      contact: {
        name: 'APIæ”¯æŒ',
        email: 'support@sslab.ai',
      },
    },
    servers: [
      {
        url: `http://localhost:${config.port}/api`,
        description: 'å¼€å‘ç¯å¢ƒ',
      },
      {
        url: 'https://api.sslab.ai',
        description: 'ç”Ÿäº§ç¯å¢ƒ',
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
        },
      },
    },
    security: [
      {
        bearerAuth: [],
      },
    ],
  },
  apis: ['./src/routes/*.ts', './src/models/*.ts'],
};

class APIServer {
  private app: Express;
  private server: any;
  private io: SocketIOServer | null = null;
  private isShuttingDown = false;

  constructor() {
    this.app = express();
    this.setupMiddleware();
    this.setupRoutes();
    this.setupErrorHandling();
  }

  /**
   * è®¾ç½®ä¸­é—´ä»¶
   */
  private setupMiddleware(): void {
    // å®‰å…¨å¤´è®¾ç½®
    this.app.use(helmet({
      crossOriginEmbedderPolicy: false,
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'", "https:"],
          scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
          imgSrc: ["'self'", "data:", "https:"],
          connectSrc: ["'self'", "ws:", "wss:"],
          fontSrc: ["'self'", "https:", "data:"],
          objectSrc: ["'none'"],
          mediaSrc: ["'self'"],
          frameSrc: ["'none'"],
        },
      },
    }));

    // CORSé…ç½®
    this.app.use(cors({
      origin: (origin, callback) => {
        // å¼€å‘ç¯å¢ƒå…è®¸æ‰€æœ‰æ¥æº
        if (config.environment === 'development') {
          callback(null, true);
          return;
        }

        // ç”Ÿäº§ç¯å¢ƒæ£€æŸ¥å…è®¸çš„æ¥æº
        if (!origin || config.corsOrigins.includes(origin)) {
          callback(null, true);
        } else {
          callback(new Error('CORS policy violation'));
        }
      },
      credentials: true,
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
      allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID', 'X-Timestamp'],
    }));

    // å‹ç¼©å“åº”
    this.app.use(compression());

    // è¯·æ±‚ä½“è§£æ
    this.app.use(express.json({ limit: '50mb' }));
    this.app.use(express.urlencoded({ extended: true, limit: '50mb' }));

    // è¯·æ±‚æ—¥å¿—
    this.app.use(morgan('combined', {
      stream: {
        write: (message: string) => {
          logger.info(message.trim());
        },
      },
    }));

    // è‡ªå®šä¹‰è¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶
    this.app.use(requestLogger);

    // é€Ÿç‡é™åˆ¶
    const limiter = rateLimit({
      windowMs: config.rateLimitWindowMs,
      max: config.rateLimitMax,
      message: {
        error: 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•',
        code: 429,
      },
      standardHeaders: true,
      legacyHeaders: false,
      handler: (req: Request, res: Response) => {
        logger.warn(`Rate limit exceeded for IP: ${req.ip}`);
        res.status(429).json({
          error: 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•',
          code: 429,
          timestamp: new Date().toISOString(),
        });
      },
    });
    this.app.use('/api', limiter);

    // é™æ€æ–‡ä»¶æœåŠ¡
    if (config.environment === 'production') {
      this.app.use(express.static(path.join(__dirname, '../../../frontend/build')));
    }

    // å¥åº·æ£€æŸ¥ä¸­é—´ä»¶
    this.app.use('/health', (req: Request, res: Response) => {
      res.status(200).json({
        status: 'healthy',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        version: process.env.npm_package_version || '1.0.0',
      });
    });
  }

  /**
   * è®¾ç½®è·¯ç”±
   */
  private setupRoutes(): void {
    // APIç‰ˆæœ¬å‰ç¼€
    const apiPrefix = '/api/v1';

    // Swaggeræ–‡æ¡£
    const swaggerSpecs = swaggerJsdoc(swaggerOptions);
    this.app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpecs));

    // è®¤è¯è·¯ç”±
    this.app.use(`${apiPrefix}/auth`, authRoutes);

    // å—ä¿æŠ¤çš„è·¯ç”±ï¼ˆéœ€è¦è®¤è¯ï¼‰
    this.app.use(`${apiPrefix}/experiments`, authMiddleware, experimentRoutes);
    this.app.use(`${apiPrefix}/templates`, authMiddleware, templateRoutes);
    this.app.use(`${apiPrefix}/guidance`, authMiddleware, guidanceRoutes);
    this.app.use(`${apiPrefix}/devices`, authMiddleware, deviceRoutes);
    this.app.use(`${apiPrefix}/ai`, authMiddleware, aiRoutes);
    this.app.use(`${apiPrefix}/users`, authMiddleware, userRoutes);
    this.app.use(`${apiPrefix}/upload`, authMiddleware, uploadRoutes);

    // æ ¹è·¯å¾„å¤„ç†
    this.app.get('/', (req: Request, res: Response) => {
      res.json({
        message: 'SSLAB-AIå®éªŒå¹³å°åç«¯æœåŠ¡',
        version: process.env.npm_package_version || '1.0.0',
        environment: config.environment,
        timestamp: new Date().toISOString(),
        docs: '/api-docs',
        health: '/health',
      });
    });

    // å‰ç«¯è·¯ç”±æ”¯æŒï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰
    if (config.environment === 'production') {
      this.app.get('*', (req: Request, res: Response) => {
        res.sendFile(path.join(__dirname, '../../../frontend/build/index.html'));
      });
    }

    // 404å¤„ç†
    this.app.use('*', (req: Request, res: Response) => {
      logger.warn(`404 - Route not found: ${req.method} ${req.originalUrl}`);
      res.status(404).json({
        error: 'è¯·æ±‚çš„èµ„æºä¸å­˜åœ¨',
        code: 404,
        path: req.originalUrl,
        timestamp: new Date().toISOString(),
      });
    });
  }

  /**
   * è®¾ç½®é”™è¯¯å¤„ç†
   */
  private setupErrorHandling(): void {
    // å…¨å±€é”™è¯¯å¤„ç†ä¸­é—´ä»¶
    this.app.use(errorHandler);

    // æœªæ•è·å¼‚å¸¸å¤„ç†
    process.on('uncaughtException', (error: Error) => {
      logger.error('Uncaught Exception:', error);
      this.gracefulShutdown('SIGTERM');
    });

    // æœªå¤„ç†çš„Promiseæ‹’ç»
    process.on('unhandledRejection', (reason: any, promise: Promise<any>) => {
      logger.error('Unhandled Rejection at:', promise, 'reason:', reason);
      this.gracefulShutdown('SIGTERM');
    });

    // è¿›ç¨‹ä¿¡å·å¤„ç†
    process.on('SIGTERM', () => this.gracefulShutdown('SIGTERM'));
    process.on('SIGINT', () => this.gracefulShutdown('SIGINT'));
  }

  /**
   * å¯åŠ¨æœåŠ¡å™¨
   */
  async start(): Promise<void> {
    try {
      // åˆå§‹åŒ–æ•°æ®åº“
      await connectDatabase(config.databaseUrl);
      logger.info('Database connected successfully');

      // åˆå§‹åŒ–Redis
      await initializeRedis(config.redisUrl);
      logger.info('Redis connected successfully');

      // åˆ›å»ºHTTPæœåŠ¡å™¨
      this.server = createServer(this.app);

      // è®¾ç½®WebSocket
      this.io = setupWebSocket(this.server);
      logger.info('WebSocket server initialized');

      // å¯åŠ¨æœåŠ¡å™¨
      this.server.listen(config.port, config.host, () => {
        logger.info(`ğŸš€ Server is running on http://${config.host}:${config.port}`);
        logger.info(`ğŸ“š API Documentation: http://${config.host}:${config.port}/api-docs`);
        logger.info(`ğŸ” Health Check: http://${config.host}:${config.port}/health`);
        logger.info(`ğŸŒ Environment: ${config.environment}`);
      });

      // æœåŠ¡å™¨é”™è¯¯å¤„ç†
      this.server.on('error', (error: any) => {
        if (error.syscall !== 'listen') {
          throw error;
        }

        const bind = typeof config.port === 'string'
          ? 'Pipe ' + config.port
          : 'Port ' + config.port;

        switch (error.code) {
          case 'EACCES':
            logger.error(`${bind} requires elevated privileges`);
            process.exit(1);
            break;
          case 'EADDRINUSE':
            logger.error(`${bind} is already in use`);
            process.exit(1);
            break;
          default:
            throw error;
        }
      });

    } catch (error) {
      logger.error('Failed to start server:', error);
      process.exit(1);
    }
  }

  /**
   * ä¼˜é›…å…³é—­æœåŠ¡å™¨
   */
  private async gracefulShutdown(signal: string): Promise<void> {
    if (this.isShuttingDown) {
      return;
    }

    this.isShuttingDown = true;
    logger.info(`ğŸ›‘ Received ${signal}. Starting graceful shutdown...`);

    try {
      // åœæ­¢æ¥å—æ–°è¿æ¥
      if (this.server) {
        this.server.close(() => {
          logger.info('HTTP server closed');
        });
      }

      // å…³é—­WebSocketè¿æ¥
      if (this.io) {
        this.io.close(() => {
          logger.info('WebSocket server closed');
        });
      }

      // ç­‰å¾…ç°æœ‰è¿æ¥å®Œæˆ
      await new Promise((resolve) => {
        setTimeout(resolve, 5000); // 5ç§’è¶…æ—¶
      });

      logger.info('âœ… Graceful shutdown completed');
      process.exit(0);
    } catch (error) {
      logger.error('âŒ Error during graceful shutdown:', error);
      process.exit(1);
    }
  }

  /**
   * è·å–æœåŠ¡å™¨å®ä¾‹
   */
  getApp(): Express {
    return this.app;
  }

  /**
   * è·å–WebSocketå®ä¾‹
   */
  getIO(): SocketIOServer | null {
    return this.io;
  }
}

// åˆ›å»ºå¹¶å¯åŠ¨æœåŠ¡å™¨
const server = new APIServer();

// ä»…åœ¨ç›´æ¥è¿è¡Œæ—¶å¯åŠ¨æœåŠ¡å™¨
if (require.main === module) {
  server.start().catch((error) => {
    logger.error('Failed to start application:', error);
    process.exit(1);
  });
}

export default server;
export { APIServer };
```

## 5. åç«¯AIæœåŠ¡æ¨¡å— (backend/src/services/ai.service.ts)

```typescript
import axios, { AxiosInstance, AxiosResponse } from 'axios';
import { EventEmitter } from 'events';
import WebSocket from 'ws';
import { Redis } from 'ioredis';
import logger from '../utils/logger';
import { getRedisClient } from '../utils/redis';

// AIæ¨¡å‹ç±»å‹å®šä¹‰
export enum AIModelType {
  DOUBAO = 'doubao',
  DEEPSEEK = 'deepseek',
  CLAUDE = 'claude',
  GPT4 = 'gpt4',
  CUSTOM = 'custom'
}

// AIæ¶ˆæ¯ç±»å‹
export interface AIMessage {
  id?: string;
  role: 'system' | 'user' | 'assistant';
  content: string;
  timestamp?: Date;
  metadata?: Record<string, any>;
}

// AIä¼šè¯ç±»å‹
export interface AISession {
  id: string;
  userId: string;
  modelType: AIModelType;
  messages: AIMessage[];
  createdAt: Date;
  updatedAt: Date;
  metadata?: Record<string, any>;
}

// AIå®Œæˆé€‰é¡¹
export interface AICompletionOptions {
  temperature?: number;
  maxTokens?: number;
  topP?: number;
  frequencyPenalty?: number;
  presencePenalty?: number;
  stream?: boolean;
  systemPrompt?: string;
  experimentContext?: any;
}

// AIæ¨¡å‹é…ç½®
export interface AIModelConfig {
  modelId: string;
  apiKey: string;
  baseURL: string;
  defaultTemperature: number;
  maxTokens: number;
  outputTokenLimit: number;
  rateLimitRPM: number;
  rateLimitTPM: number;
  supportStreaming: boolean;
  features: string[];
}

// AIå“åº”ç±»å‹
export interface AIResponse {
  id: string;
  content: string;
  model: AIModelType;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  finishReason?: string;
  metadata?: Record<string, any>;
}

// é”™è¯¯ç±»å‹
export class AIServiceError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 500,
    public details?: any
  ) {
    super(message);
    this.name = 'AIServiceError';
  }
}

/**
 * AIæœåŠ¡ç±» - ç®¡ç†å¤šä¸ªAIæ¨¡å‹çš„è°ƒç”¨å’Œä¼šè¯
 */
export class AIService extends EventEmitter {
  private models: Map<AIModelType, AIModelConfig> = new Map();
  private httpClients: Map<AIModelType, AxiosInstance> = new Map();
  private wsConnections: Map<string, WebSocket> = new Map();
  private redis: Redis;
  private sessionCache: Map<string, AISession> = new Map();
  private rateLimiters: Map<string, { count: number; resetTime: number }> = new Map();

  constructor() {
    super();
    this.redis = getRedisClient();
    this.initializeModels();
    this.setupEventHandlers();
  }

  /**
   * åˆå§‹åŒ–AIæ¨¡å‹é…ç½®
   */
  private initializeModels(): void {
    // è±†åŒ…æ¨¡å‹é…ç½®
    this.models.set(AIModelType.DOUBAO, {
      modelId: 'ep-20241024235508-fqn7t',
      apiKey: process.env.DOUBAO_API_KEY || '',
      baseURL: 'https://ark.cn-beijing.volces.com/api/v3',
      defaultTemperature: 0.7,
      maxTokens: 4000,
      outputTokenLimit: 4000,
      rateLimitRPM: 300,
      rateLimitTPM: 100000,
      supportStreaming: true,
      features: ['chat', 'reasoning', 'multimodal']
    });

    // DeepSeekæ¨¡å‹é…ç½®
    this.models.set(AIModelType.DEEPSEEK, {
      modelId: 'deepseek-reasoner',
      apiKey: process.env.DEEPSEEK_API_KEY || '',
      baseURL: 'https://api.deepseek.com/v1',
      defaultTemperature: 0.8,
      maxTokens: 8000,
      outputTokenLimit: 8000,
      rateLimitRPM: 200,
      rateLimitTPM: 50000,
      supportStreaming: true,
      features: ['chat', 'reasoning', 'code', 'analysis']
    });

    // åˆå§‹åŒ–HTTPå®¢æˆ·ç«¯
    this.models.forEach((config, modelType) => {
      const client = axios.create({
        baseURL: config.baseURL,
        timeout: 60000,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${config.apiKey}`,
        },
      });

      // è¯·æ±‚æ‹¦æˆªå™¨
      client.interceptors.request.use((requestConfig) => {
        logger.debug(`AI API Request: ${modelType}`, {
          url: requestConfig.url,
          method: requestConfig.method,
        });
        return requestConfig;
      });

      // å“åº”æ‹¦æˆªå™¨
      client.interceptors.response.use(
        (response) => {
          logger.debug(`AI API Response: ${modelType}`, {
            status: response.status,
            usage: response.data?.usage,
          });
          return response;
        },
        (error) => {
          logger.error(`AI API Error: ${modelType}`, {
            status: error.response?.status,
            message: error.response?.data?.message || error.message,
          });
          throw new AIServiceError(
            error.response?.data?.message || 'AI APIè°ƒç”¨å¤±è´¥',
            'API_ERROR',
            error.response?.status || 500,
            error.response?.data
          );
        }
      );

      this.httpClients.set(modelType, client);
    });
  }

  /**
   * è®¾ç½®äº‹ä»¶å¤„ç†å™¨
   */
  private setupEventHandlers(): void {
    this.on('messageGenerated', (sessionId: string, message: AIMessage) => {
      logger.info(`AI message generated for session: ${sessionId}`);
      this.cacheMessage(sessionId, message);
    });

    this.on('sessionCreated', (session: AISession) => {
      logger.info(`AI session created: ${session.id}`);
      this.cacheSession(session);
    });

    this.on('error', (error: Error) => {
      logger.error('AI Service Error:', error);
    });
  }

  /**
   * åˆ›å»ºAIä¼šè¯
   */
  async createSession(
    userId: string,
    modelType: AIModelType = AIModelType.DOUBAO,
    metadata?: Record<string, any>
  ): Promise<AISession> {
    const session: AISession = {
      id: this.generateSessionId(),
      userId,
      modelType,
      messages: [],
      createdAt: new Date(),
      updatedAt: new Date(),
      metadata
    };

    // ç¼“å­˜ä¼šè¯
    await this.cacheSession(session);
    
    this.emit('sessionCreated', session);
    return session;
  }

  /**
   * å‘é€æ¶ˆæ¯åˆ°AIæ¨¡å‹
   */
  async sendMessage(
    sessionId: string,
    message: string,
    options?: AICompletionOptions
  ): Promise<AIResponse> {
    try {
      // è·å–ä¼šè¯
      const session = await this.getSession(sessionId);
      if (!session) {
        throw new AIServiceError('ä¼šè¯ä¸å­˜åœ¨', 'SESSION_NOT_FOUND', 404);
      }

      // æ£€æŸ¥é€Ÿç‡é™åˆ¶
      await this.checkRateLimit(session.modelType, session.userId);

      // å‡†å¤‡æ¶ˆæ¯
      const userMessage: AIMessage = {
        id: this.generateMessageId(),
        role: 'user',
        content: message,
        timestamp: new Date()
      };

      // æ·»åŠ åˆ°ä¼šè¯
      session.messages.push(userMessage);

      // è°ƒç”¨AIæ¨¡å‹
      const response = await this.callAIModel(session, options);

      // åˆ›å»ºåŠ©æ‰‹æ¶ˆæ¯
      const assistantMessage: AIMessage = {
        id: response.id,
        role: 'assistant',
        content: response.content,
        timestamp: new Date(),
        metadata: {
          model: response.model,
          usage: response.usage,
          finishReason: response.finishReason
        }
      };

      // æ·»åŠ åˆ°ä¼šè¯
      session.messages.push(assistantMessage);
      session.updatedAt = new Date();

      // æ›´æ–°ç¼“å­˜
      await this.cacheSession(session);

      this.emit('messageGenerated', sessionId, assistantMessage);
      return response;

    } catch (error) {
      logger.error('Error sending AI message:', error);
      if (error instanceof AIServiceError) {
        throw error;
      }
      throw new AIServiceError('å‘é€æ¶ˆæ¯å¤±è´¥', 'SEND_MESSAGE_ERROR', 500, error);
    }
  }

  /**
   * æµå¼å‘é€æ¶ˆæ¯
   */
  async sendMessageStream(
    sessionId: string,
    message: string,
    onChunk: (chunk: string) => void,
    options?: AICompletionOptions
  ): Promise<AIResponse> {
    try {
      const session = await this.getSession(sessionId);
      if (!session) {
        throw new AIServiceError('ä¼šè¯ä¸å­˜åœ¨', 'SESSION_NOT_FOUND', 404);
      }

      // æ£€æŸ¥æ¨¡å‹æ˜¯å¦æ”¯æŒæµå¼è¾“å‡º
      const modelConfig = this.models.get(session.modelType);
      if (!modelConfig?.supportStreaming) {
        throw new AIServiceError('è¯¥æ¨¡å‹ä¸æ”¯æŒæµå¼è¾“å‡º', 'STREAMING_NOT_SUPPORTED', 400);
      }

      return await this.callAIModelStream(session, message, onChunk, options);

    } catch (error) {
      logger.error('Error sending AI message stream:', error);
      throw error;
    }
  }

  /**
   * è°ƒç”¨AIæ¨¡å‹
   */
  private async callAIModel(
    session: AISession,
    options?: AICompletionOptions
  ): Promise<AIResponse> {
    const modelConfig = this.models.get(session.modelType);
    const client = this.httpClients.get(session.modelType);

    if (!modelConfig || !client) {
      throw new AIServiceError('æ¨¡å‹é…ç½®ä¸å­˜åœ¨', 'MODEL_NOT_CONFIGURED', 500);
    }

    // å‡†å¤‡è¯·æ±‚å‚æ•°
    const requestData = this.prepareRequestData(session, modelConfig, options);

    try {
      const response: AxiosResponse = await client.post('/chat/completions', requestData);
      return this.parseAIResponse(response.data, session.modelType);
    } catch (error) {
      throw this.handleAPIError(error, session.modelType);
    }
  }

  /**
   * æµå¼è°ƒç”¨AIæ¨¡å‹
   */
  private async callAIModelStream(
    session: AISession,
    message: string,
    onChunk: (chunk: string) => void,
    options?: AICompletionOptions
  ): Promise<AIResponse> {
    const modelConfig = this.models.get(session.modelType);
    if (!modelConfig) {
      throw new AIServiceError('æ¨¡å‹é…ç½®ä¸å­˜åœ¨', 'MODEL_NOT_CONFIGURED', 500);
    }

    // å®ç°æµå¼è°ƒç”¨é€»è¾‘
    return new Promise((resolve, reject) => {
      // è¿™é‡Œå®ç°WebSocketæˆ–SSEæµå¼è°ƒç”¨
      // ç®€åŒ–å®ç°ï¼Œå®é™…åº”ä½¿ç”¨WebSocketæˆ–Server-Sent Events
      setTimeout(() => {
        const mockResponse: AIResponse = {
          id: this.generateMessageId(),
          content: `è¿™æ˜¯å¯¹"${message}"çš„AIå›å¤ï¼ˆæµå¼æ¨¡å¼ï¼‰`,
          model: session.modelType,
          usage: {
            promptTokens: 50,
            completionTokens: 100,
            totalTokens: 150
          }
        };
        resolve(mockResponse);
      }, 1000);
    });
  }

  /**
   * å‡†å¤‡è¯·æ±‚æ•°æ®
   */
  private prepareRequestData(
    session: AISession,
    modelConfig: AIModelConfig,
    options?: AICompletionOptions
  ): any {
    const messages = session.messages.map(msg => ({
      role: msg.role,
      content: msg.content
    }));

    // æ·»åŠ ç³»ç»Ÿæç¤º
    if (options?.systemPrompt) {
      messages.unshift({
        role: 'system',
        content: options.systemPrompt
      });
    }

    return {
      model: modelConfig.modelId,
      messages,
      temperature: options?.temperature ?? modelConfig.defaultTemperature,
      max_tokens: Math.min(
        options?.maxTokens ?? modelConfig.maxTokens,
        modelConfig.outputTokenLimit
      ),
      top_p: options?.topP ?? 1.0,
      frequency_penalty: options?.frequencyPenalty ?? 0,
      presence_penalty: options?.presencePenalty ?? 0,
      stream: options?.stream ?? false,
      user: session.userId
    };
  }

  /**
   * è§£æAIå“åº”
   */
  private parseAIResponse(data: any, modelType: AIModelType): AIResponse {
    const choice = data.choices?.[0];
    if (!choice) {
      throw new AIServiceError('æ— æ•ˆçš„AIå“åº”', 'INVALID_RESPONSE', 500);
    }

    return {
      id: data.id || this.generateMessageId(),
      content: choice.message?.content || '',
      model: modelType,
      usage: data.usage,
      finishReason: choice.finish_reason,
      metadata: {
        created: data.created,
        object: data.object
      }
    };
  }

  /**
   * å¤„ç†APIé”™è¯¯
   */
  private handleAPIError(error: any, modelType: AIModelType): AIServiceError {
    if (error.response) {
      const status = error.response.status;
      const message = error.response.data?.message || error.message;

      switch (status) {
        case 401:
          return new AIServiceError(`${modelType}æ¨¡å‹è®¤è¯å¤±è´¥`, 'AUTH_ERROR', 401);
        case 429:
          return new AIServiceError(`${modelType}æ¨¡å‹è¯·æ±‚é¢‘ç‡è¶…é™`, 'RATE_LIMIT', 429);
        case 500:
          return new AIServiceError(`${modelType}æ¨¡å‹æœåŠ¡å™¨é”™è¯¯`, 'SERVER_ERROR', 500);
        default:
          return new AIServiceError(message, 'API_ERROR', status);
      }
    }

    return new AIServiceError('ç½‘ç»œè¿æ¥å¤±è´¥', 'NETWORK_ERROR', 503);
  }

  /**
   * è·å–ä¼šè¯
   */
  private async getSession(sessionId: string): Promise<AISession | null> {
    // å…ˆä»ç¼“å­˜æŸ¥æ‰¾
    if (this.sessionCache.has(sessionId)) {
      return this.sessionCache.get(sessionId)!;
    }

    // ä»RedisæŸ¥æ‰¾
    try {
      const cached = await this.redis.get(`ai_session:${sessionId}`);
      if (cached) {
        const session: AISession = JSON.parse(cached);
        this.sessionCache.set(sessionId, session);
        return session;
      }
    } catch (error) {
      logger.error('Error getting session from Redis:', error);
    }

    return null;
  }

  /**
   * ç¼“å­˜ä¼šè¯
   */
  private async cacheSession(session: AISession): Promise<void> {
    // å†…å­˜ç¼“å­˜
    this.sessionCache.set(session.id, session);

    // Redisç¼“å­˜
    try {
      await this.redis.setex(
        `ai_session:${session.id}`,
        3600, // 1å°æ—¶è¿‡æœŸ
        JSON.stringify(session)
      );
    } catch (error) {
      logger.error('Error caching session to Redis:', error);
    }
  }

  /**
   * ç¼“å­˜æ¶ˆæ¯
   */
  private async cacheMessage(sessionId: string, message: AIMessage): Promise<void> {
    try {
      await this.redis.lpush(
        `ai_messages:${sessionId}`,
        JSON.stringify(message)
      );
      await this.redis.expire(`ai_messages:${sessionId}`, 86400); // 24å°æ—¶è¿‡æœŸ
    } catch (error) {
      logger.error('Error caching message to Redis:', error);
    }
  }

  /**
   * æ£€æŸ¥é€Ÿç‡é™åˆ¶
   */
  private async checkRateLimit(modelType: AIModelType, userId: string): Promise<void> {
    const modelConfig = this.models.get(modelType);
    if (!modelConfig) return;

    const key = `${modelType}:${userId}`;
    const now = Date.now();
    const windowMs = 60000; // 1åˆ†é’Ÿçª—å£

    let limiter = this.rateLimiters.get(key);
    if (!limiter || now > limiter.resetTime) {
      limiter = { count: 0, resetTime: now + windowMs };
      this.rateLimiters.set(key, limiter);
    }

    if (limiter.count >= modelConfig.rateLimitRPM) {
      throw new AIServiceError(
        'è¯·æ±‚é¢‘ç‡è¶…é™ï¼Œè¯·ç¨åå†è¯•',
        'RATE_LIMIT_EXCEEDED',
        429
      );
    }

    limiter.count++;
  }

  /**
   * ç”Ÿæˆä¼šè¯ID
   */
  private generateSessionId(): string {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * ç”Ÿæˆæ¶ˆæ¯ID
   */
  private generateMessageId(): string {
    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * è·å–æ¨¡å‹åˆ—è¡¨
   */
  getAvailableModels(): AIModelType[] {
    return Array.from(this.models.keys());
  }

  /**
   * è·å–æ¨¡å‹é…ç½®
   */
  getModelConfig(modelType: AIModelType): AIModelConfig | undefined {
    return this.models.get(modelType);
  }

  /**
   * åˆ é™¤ä¼šè¯
   */
  async deleteSession(sessionId: string): Promise<boolean> {
    try {
      // ä»ç¼“å­˜åˆ é™¤
      this.sessionCache.delete(sessionId);

      // ä»Redisåˆ é™¤
      await this.redis.del(`ai_session:${sessionId}`);
      await this.redis.del(`ai_messages:${sessionId}`);

      return true;
    } catch (error) {
      logger.error('Error deleting session:', error);
      return false;
    }
  }

  /**
   * æ¸…ç†è¿‡æœŸä¼šè¯
   */
  async cleanupExpiredSessions(): Promise<void> {
    try {
      const pattern = 'ai_session:*';
      const keys = await this.redis.keys(pattern);
      
      for (const key of keys) {
        const ttl = await this.redis.ttl(key);
        if (ttl <= 0) {
          await this.redis.del(key);
        }
      }

      logger.info(`Cleaned up ${keys.length} expired sessions`);
    } catch (error) {
      logger.error('Error cleaning up expired sessions:', error);
    }
  }
}

// åˆ›å»ºå¹¶å¯¼å‡ºAIæœåŠ¡å®ä¾‹
const aiService = new AIService();
export default aiService;
```

## 6. å‰ç«¯ç±»å‹å®šä¹‰ç³»ç»Ÿ (frontend/src/types/index.ts)

```typescript
// åŸºç¡€ç±»å‹å®šä¹‰
export interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  deleted?: boolean;
}

// ç”¨æˆ·ç›¸å…³ç±»å‹
export interface User extends BaseEntity {
  email: string;
  username: string;
  displayName: string;
  avatar?: string;
  role: UserRole;
  status: UserStatus;
  profile: UserProfile;
  preferences: UserPreferences;
  lastLoginAt?: Date;
  emailVerified: boolean;
  phoneVerified: boolean;
}

export enum UserRole {
  STUDENT = 'student',
  TEACHER = 'teacher',
  ADMIN = 'admin',
  SUPER_ADMIN = 'super_admin'
}

export enum UserStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  SUSPENDED = 'suspended',
  PENDING = 'pending'
}

export interface UserProfile {
  firstName: string;
  lastName: string;
  phone?: string;
  organization?: string;
  department?: string;
  grade?: string;
  bio?: string;
  location?: string;
  website?: string;
  socialLinks?: Record<string, string>;
}

export interface UserPreferences {
  language: string;
  theme: 'light' | 'dark' | 'auto';
  timezone: string;
  notifications: NotificationSettings;
  privacy: PrivacySettings;
  accessibility: AccessibilitySettings;
}

export interface NotificationSettings {
  email: boolean;
  push: boolean;
  sms: boolean;
  experimentReminders: boolean;
  systemUpdates: boolean;
  weeklyDigest: boolean;
}

export interface PrivacySettings {
  profileVisible: boolean;
  experimentsVisible: boolean;
  allowDataCollection: boolean;
  allowAnalytics: boolean;
}

export interface AccessibilitySettings {
  highContrast: boolean;
  largeText: boolean;
  screenReader: boolean;
  reducedMotion: boolean;
  keyboardNavigation: boolean;
}

// å®éªŒç›¸å…³ç±»å‹
export interface Experiment extends BaseEntity {
  title: string;
  description: string;
  objectives: string[];
  instructions: ExperimentInstruction[];
  authorId: string;
  author: User;
  templateId?: string;
  template?: ExperimentTemplate;
  category: ExperimentCategory;
  difficulty: ExperimentDifficulty;
  estimatedDuration: number; // åˆ†é’Ÿ
  status: ExperimentStatus;
  visibility: ExperimentVisibility;
  tags: string[];
  resources: ExperimentResource[];
  requirements: ExperimentRequirement[];
  metadata: ExperimentMetadata;
  sessions: ExperimentSession[];
  analytics: ExperimentAnalytics;
  version: number;
  publishedAt?: Date;
  archivedAt?: Date;
}

export interface ExperimentInstruction {
  step: number;
  title: string;
  content: string;
  images?: string[];
  videos?: string[];
  interactive?: boolean;
  estimatedTime?: number;
  tips?: string[];
  warnings?: string[];
}

export enum ExperimentCategory {
  PHYSICS = 'physics',
  CHEMISTRY = 'chemistry',
  BIOLOGY = 'biology',
  MATHEMATICS = 'mathematics',
  COMPUTER_SCIENCE = 'computer_science',
  ENGINEERING = 'engineering',
  ENVIRONMENTAL = 'environmental',
  INTERDISCIPLINARY = 'interdisciplinary'
}

export enum ExperimentDifficulty {
  BEGINNER = 'beginner',
  INTERMEDIATE = 'intermediate',
  ADVANCED = 'advanced',
  EXPERT = 'expert'
}

export enum ExperimentStatus {
  DRAFT = 'draft',
  REVIEW = 'review',
  PUBLISHED = 'published',
  ARCHIVED = 'archived',
  DEPRECATED = 'deprecated'
}

export enum ExperimentVisibility {
  PUBLIC = 'public',
  PRIVATE = 'private',
  ORGANIZATION = 'organization',
   INVITED = 'invited'
}

export interface ExperimentResource {
  id: string;
  name: string;
  type: ResourceType;
  url?: string;
  content?: string;
  metadata?: Record<string, any>;
  required: boolean;
  quantity?: number;
  specifications?: Record<string, any>;
}

export enum ResourceType {
  EQUIPMENT = 'equipment',
  MATERIAL = 'material',
  SOFTWARE = 'software',
  DOCUMENT = 'document',
  VIDEO = 'video',
  LINK = 'link',
  FILE = 'file'
}

export interface ExperimentRequirement {
  type: RequirementType;
  description: string;
  level: RequirementLevel;
  optional: boolean;
}

export enum RequirementType {
  KNOWLEDGE = 'knowledge',
  SKILL = 'skill',
  EQUIPMENT = 'equipment',
  SOFTWARE = 'software',
  TIME = 'time',
  SPACE = 'space'
}

export enum RequirementLevel {
  BASIC = 'basic',
  INTERMEDIATE = 'intermediate',
  ADVANCED = 'advanced'
}

export interface ExperimentMetadata {
  keywords: string[];
  academicLevel: string[];
  subjects: string[];
  learningOutcomes: string[];
  assessmentMethods: string[];
  safetyConsiderations: string[];
  adaptations?: string[];
  extensions?: string[];
}

// å®éªŒä¼šè¯ç±»å‹
export interface ExperimentSession extends BaseEntity {
  experimentId: string;
  experiment: Experiment;
  userId: string;
  user: User;
  groupId?: string;
  group?: ExperimentGroup;
  status: SessionStatus;
  startedAt?: Date;
  completedAt?: Date;
  pausedAt?: Date;
  duration: number; // æ¯«ç§’
  currentStep: number;
  totalSteps: number;
  progress: number; // 0-100
  data: SessionData;
  observations: Observation[];
  results: SessionResult[];
  feedback?: SessionFeedback;
  aiInteractions: AIInteraction[];
  metadata: Record<string, any>;
}

export enum SessionStatus {
  NOT_STARTED = 'not_started',
  IN_PROGRESS = 'in_progress',
  PAUSED = 'paused',
  COMPLETED = 'completed',
  ABANDONED = 'abandoned',
  ERROR = 'error'
}

export interface SessionData {
  stepProgress: StepProgress[];
  measurements: Measurement[];
  calculations: Calculation[];
  notes: Note[];
  attachments: Attachment[];
  variables: Record<string, any>;
  settings: Record<string, any>;
}

export interface StepProgress {
  stepNumber: number;
  status: StepStatus;
  startedAt?: Date;
  completedAt?: Date;
  duration?: number;
  attempts: number;
  errors: string[];
  data?: Record<string, any>;
}

export enum StepStatus {
  PENDING = 'pending',
  IN_PROGRESS = 'in_progress',
  COMPLETED = 'completed',
  SKIPPED = 'skipped',
  ERROR = 'error'
}

export interface Measurement {
  id: string;
  name: string;
  value: number | string;
  unit?: string;
  timestamp: Date;
  stepNumber?: number;
  metadata?: Record<string, any>;
  validated?: boolean;
  accuracy?: number;
}

export interface Calculation {
  id: string;
  name: string;
  formula: string;
  inputs: Record<string, number>;
  result: number;
  unit?: string;
  timestamp: Date;
  stepNumber?: number;
  validated?: boolean;
}

export interface Note {
  id: string;
  content: string;
  timestamp: Date;
  stepNumber?: number;
  tags?: string[];
  type: NoteType;
  attachments?: string[];
}

export enum NoteType {
  OBSERVATION = 'observation',
  QUESTION = 'question',
  IDEA = 'idea',
  ISSUE = 'issue',
  SOLUTION = 'solution',
  REMINDER = 'reminder'
}

export interface Attachment {
  id: string;
  name: string;
  type: AttachmentType;
  url: string;
  size: number;
  timestamp: Date;
  stepNumber?: number;
  metadata?: Record<string, any>;
}

export enum AttachmentType {
  IMAGE = 'image',
  VIDEO = 'video',
  AUDIO = 'audio',
  DOCUMENT = 'document',
  DATA = 'data',
  OTHER = 'other'
}

// AIç›¸å…³ç±»å‹
export interface AIInteraction extends BaseEntity {
  sessionId: string;
  userId: string;
  type: AIInteractionType;
  input: string;
  output: string;
  context?: Record<string, any>;
  modelUsed: string;
  confidence?: number;
  feedback?: AIFeedback;
  tokens: {
    prompt: number;
    completion: number;
    total: number;
  };
  duration: number;
  stepNumber?: number;
}

export enum AIInteractionType {
  QUESTION = 'question',
  GUIDANCE = 'guidance',
  EXPLANATION = 'explanation',
  ANALYSIS = 'analysis',
  SUGGESTION = 'suggestion',
  VALIDATION = 'validation',
  TROUBLESHOOTING = 'troubleshooting'
}

export interface AIFeedback {
  helpful: boolean;
  accurate: boolean;
  relevant: boolean;
  clear: boolean;
  rating: number; // 1-5
  comments?: string;
  timestamp: Date;
}

// æ¨¡æ¿ç›¸å…³ç±»å‹
export interface ExperimentTemplate extends BaseEntity {
  title: string;
  description: string;
  category: ExperimentCategory;
  difficulty: ExperimentDifficulty;
  objectives: string[];
  instructions: ExperimentInstruction[];
  resources: ExperimentResource[];
  requirements: ExperimentRequirement[];
  metadata: ExperimentMetadata;
  authorId: string;
  author: User;
  organizationId?: string;
  version: number;
  status: TemplateStatus;
  visibility: ExperimentVisibility;
  tags: string[];
  usage: TemplateUsage;
  ratings: TemplateRating[];
  reviews: TemplateReview[];
  forks: number;
  stars: number;
  downloads: number;
}

export enum TemplateStatus {
  DRAFT = 'draft',
  PUBLISHED = 'published',
  FEATURED = 'featured',
  DEPRECATED = 'deprecated',
  ARCHIVED = 'archived'
}

export interface TemplateUsage {
  totalUses: number;
  recentUses: number;
  averageRating: number;
  successRate: number;
  completionRate: number;
  averageDuration: number;
}

export interface TemplateRating {
  userId: string;
  rating: number; // 1-5
  timestamp: Date;
}

export interface TemplateReview {
  id: string;
  userId: string;
  user: User;
  rating: number; // 1-5
  title: string;
  content: string;
  pros?: string[];
  cons?: string[];
  recommendations?: string[];
  verified: boolean;
  helpful: number;
  timestamp: Date;
}

// APIå“åº”ç±»å‹
export interface ApiResponse<T = any> {
  success: boolean;
  data: T;
  message?: string;
  errors?: ApiError[];
  pagination?: PaginationInfo;
  metadata?: Record<string, any>;
}

export interface ApiError {
  code: string;
  message: string;
  field?: string;
  details?: any;
}

export interface PaginationInfo {
  page: number;
  limit: number;
  total: number;
  totalPages: number;
  hasNext: boolean;
  hasPrev: boolean;
}

// è¡¨å•ç›¸å…³ç±»å‹
export interface FormField {
  name: string;
  label: string;
  type: FormFieldType;
  required: boolean;
  validation?: ValidationRule[];
  options?: FormFieldOption[];
  placeholder?: string;
  helpText?: string;
  defaultValue?: any;
  disabled?: boolean;
  visible?: boolean;
}

export enum FormFieldType {
  TEXT = 'text',
  EMAIL = 'email',
  PASSWORD = 'password',
  NUMBER = 'number',
  TEXTAREA = 'textarea',
  SELECT = 'select',
  MULTISELECT = 'multiselect',
  CHECKBOX = 'checkbox',
  RADIO = 'radio',
  DATE = 'date',
  TIME = 'time',
  DATETIME = 'datetime',
  FILE = 'file',
  IMAGE = 'image',
  URL = 'url',
  COLOR = 'color',
  RANGE = 'range'
}

export interface FormFieldOption {
  label: string;
  value: any;
  disabled?: boolean;
  group?: string;
}

export interface ValidationRule {
  type: ValidationType;
  value?: any;
  message?: string;
  customValidator?: (value: any) => boolean | string;
}

export enum ValidationType {
  REQUIRED = 'required',
  MIN_LENGTH = 'minLength',
  MAX_LENGTH = 'maxLength',
  MIN_VALUE = 'minValue',
  MAX_VALUE = 'maxValue',
  PATTERN = 'pattern',
  EMAIL = 'email',
  URL = 'url',
  CUSTOM = 'custom'
}

// æƒé™ç›¸å…³ç±»å‹
export interface Permission {
  id: string;
  name: string;
  description: string;
  resource: string;
  action: string;
  conditions?: Record<string, any>;
}

export interface Role {
  id: string;
  name: string;
  description: string;
  permissions: Permission[];
  hierarchy: number;
  system: boolean;
}

// ç³»ç»Ÿé…ç½®ç±»å‹
export interface SystemConfig {
  features: FeatureConfig;
  limits: SystemLimits;
  integrations: IntegrationConfig;
  security: SecurityConfig;
  ui: UIConfig;
}

export interface FeatureConfig {
  aiAssistant: boolean;
  templates: boolean;
  collaboration: boolean;
  analytics: boolean;
  reporting: boolean;
  notifications: boolean;
  fileUpload: boolean;
  videoCall: boolean;
  chat: boolean;
  calendar: boolean;
}

export interface SystemLimits {
  maxExperimentsPerUser: number;
  maxSessionDuration: number;
  maxFileSize: number;
  maxStoragePerUser: number;
  maxGroupSize: number;
  maxTemplatesPerUser: number;
  rateLimits: Record<string, number>;
}

export interface IntegrationConfig {
  oauth: OAuthConfig;
  analytics: AnalyticsConfig;
  storage: StorageConfig;
  email: EmailConfig;
  sms: SMSConfig;
}

export interface OAuthConfig {
  google: boolean;
  microsoft: boolean;
  github: boolean;
  wechat: boolean;
}

export interface AnalyticsConfig {
  enabled: boolean;
  provider: string;
  trackingId: string;
  customEvents: boolean;
}

export interface StorageConfig {
  provider: string;
  bucket: string;
  region: string;
  cdn: boolean;
}

export interface EmailConfig {
  provider: string;
  from: string;
  templates: Record<string, string>;
}

export interface SMSConfig {
  provider: string;
  from: string;
  templates: Record<string, string>;
}

export interface SecurityConfig {
  passwordPolicy: PasswordPolicy;
  sessionTimeout: number;
  mfaRequired: boolean;
  ipWhitelist: string[];
  rateLimiting: boolean;
  encryption: EncryptionConfig;
}

export interface PasswordPolicy {
  minLength: number;
  requireUppercase: boolean;
  requireLowercase: boolean;
  requireNumbers: boolean;
  requireSpecialChars: boolean;
  maxAge: number;
  preventReuse: number;
}

export interface EncryptionConfig {
  algorithm: string;
  keyLength: number;
  saltRounds: number;
}

export interface UIConfig {
  theme: ThemeConfig;
  branding: BrandingConfig;
  layout: LayoutConfig;
  accessibility: AccessibilityConfig;
}

export interface ThemeConfig {
  primaryColor: string;
  secondaryColor: string;
  accentColor: string;
  errorColor: string;
  warningColor: string;
  successColor: string;
  infoColor: string;
  darkMode: boolean;
  customCss?: string;
}

export interface BrandingConfig {
  logo: string;
  favicon: string;
  title: string;
  description: string;
  footer: string;
  socialLinks: Record<string, string>;
}

export interface LayoutConfig {
  sidebar: SidebarConfig;
  header: HeaderConfig;
  footer: FooterConfig;
}

export interface SidebarConfig {
  collapsible: boolean;
  defaultCollapsed: boolean;
  position: 'left' | 'right';
  width: number;
}

export interface HeaderConfig {
  fixed: boolean;
  height: number;
  showSearch: boolean;
  showNotifications: boolean;
  showProfile: boolean;
}

export interface FooterConfig {
  show: boolean;
  height: number;
  content: string;
}

export interface AccessibilityConfig {
  highContrast: boolean;
  largeText: boolean;
  keyboardNavigation: boolean;
  screenReaderSupport: boolean;
  reducedMotion: boolean;
}

// å¯¼å‡ºæ‰€æœ‰ç±»å‹
export * from './api';
export * from './auth';
export * from './experiment';
export * from './template';
export * from './ai';
export * from './user';
export * from './form';
export * from './system';
```

## 7. åç«¯æ•°æ®æ¨¡å‹å±‚ (backend/src/models/experiment.model.ts)

```typescript
import mongoose, { Schema, Document, Model } from 'mongoose';
import { User } from './user.model';
import { ExperimentTemplate } from './template.model';

// å®éªŒçŠ¶æ€æšä¸¾
export enum ExperimentStatus {
  DRAFT = 'draft',
  PUBLISHED = 'published',
  ARCHIVED = 'archived',
  UNDER_REVIEW = 'under_review'
}

// å®éªŒå¯è§æ€§æšä¸¾
export enum ExperimentVisibility {
  PUBLIC = 'public',
  PRIVATE = 'private',
  ORGANIZATION = 'organization',
  INVITED_ONLY = 'invited_only'
}

// å®éªŒç±»åˆ«æšä¸¾
export enum ExperimentCategory {
  PHYSICS = 'physics',
  CHEMISTRY = 'chemistry',
  BIOLOGY = 'biology',
  MATHEMATICS = 'mathematics',
  COMPUTER_SCIENCE = 'computer_science',
  ENGINEERING = 'engineering',
  ENVIRONMENTAL = 'environmental',
  INTERDISCIPLINARY = 'interdisciplinary'
}

// å®éªŒéš¾åº¦æšä¸¾
export enum ExperimentDifficulty {
  BEGINNER = 'beginner',
  INTERMEDIATE = 'intermediate',
  ADVANCED = 'advanced',
  EXPERT = 'expert'
}

// å®éªŒæŒ‡ä»¤æ¥å£
export interface IExperimentInstruction {
  step: number;
  title: string;
  content: string;
  images?: string[];
  videos?: string[];
  interactive?: boolean;
  estimatedTime?: number; // åˆ†é’Ÿ
  tips?: string[];
  warnings?: string[];
  requirements?: string[];
  expectedResults?: string[];
}

// å®éªŒèµ„æºæ¥å£
export interface IExperimentResource {
  id: string;
  name: string;
  type: 'equipment' | 'material' | 'software' | 'document' | 'video' | 'link';
  description?: string;
  url?: string;
  quantity?: number;
  required: boolean;
  specifications?: Record<string, any>;
  cost?: number;
  supplier?: string;
  alternatives?: string[];
}

// å®éªŒè¦æ±‚æ¥å£
export interface IExperimentRequirement {
  type: 'knowledge' | 'skill' | 'equipment' | 'software' | 'time' | 'space';
  description: string;
  level: 'basic' | 'intermediate' | 'advanced';
  optional: boolean;
  details?: string;
}

// å®éªŒå…ƒæ•°æ®æ¥å£
export interface IExperimentMetadata {
  keywords: string[];
  academicLevel: string[];
  subjects: string[];
  learningOutcomes: string[];
  assessmentMethods: string[];
  safetyConsiderations: string[];
  adaptations?: string[];
  extensions?: string[];
  references?: string[];
  relatedExperiments?: string[];
}

// å®éªŒåˆ†ææ¥å£
export interface IExperimentAnalytics {
  totalViews: number;
  totalStarts: number;
  totalCompletions: number;
  averageRating: number;
  totalRatings: number;
  averageDuration: number;
  successRate: number;
  abandonmentRate: number;
  stepAnalytics: IStepAnalytics[];
  userFeedback: IUserFeedback[];
  performanceMetrics: IPerformanceMetrics;
  lastAnalyzedAt: Date;
}

export interface IStepAnalytics {
  stepNumber: number;
  completionRate: number;
  averageTime: number;
  commonErrors: string[];
  helpRequests: number;
  skipRate: number;
}

export interface IUserFeedback {
  userId: string;
  rating: number; // 1-5
  comment?: string;
  category: 'difficulty' | 'clarity' | 'engagement' | 'relevance' | 'technical';
  helpful: boolean;
  timestamp: Date;
}

export interface IPerformanceMetrics {
  popularityScore: number;
  qualityScore: number;
  engagementScore: number;
  educationalValue: number;
  technicalComplexity: number;
  trending: boolean;
  featured: boolean;
}

// å®éªŒæ–‡æ¡£æ¥å£
export interface IExperiment extends Document {
  title: string;
  description: string;
  shortDescription?: string;
  objectives: string[];
  instructions: IExperimentInstruction[];
  authorId: mongoose.Types.ObjectId;
  author?: IUser; // è™šæ‹Ÿå­—æ®µ
  templateId?: mongoose.Types.ObjectId;
  template?: IExperimentTemplate; // è™šæ‹Ÿå­—æ®µ
  category: ExperimentCategory;
  subcategory?: string;
  difficulty: ExperimentDifficulty;
  estimatedDuration: number; // åˆ†é’Ÿ
  status: ExperimentStatus;
  visibility: ExperimentVisibility;
  tags: string[];
  resources: IExperimentResource[];
  requirements: IExperimentRequirement[];
  metadata: IExperimentMetadata;
  analytics: IExperimentAnalytics;
  version: number;
  collaborators: mongoose.Types.ObjectId[];
  reviewers: mongoose.Types.ObjectId[];
  publishedAt?: Date;
  archivedAt?: Date;
  lastModifiedBy: mongoose.Types.ObjectId;
  changeLog: IChangeLogEntry[];
  
  // è™šæ‹Ÿå­—æ®µ
  sessions?: IExperimentSession[];
  ratings?: IExperimentRating[];
  
  // å®ä¾‹æ–¹æ³•
  publish(): Promise<IExperiment>;
  archive(): Promise<IExperiment>;
  addCollaborator(userId: mongoose.Types.ObjectId): Promise<IExperiment>;
  removeCollaborator(userId: mongoose.Types.ObjectId): Promise<IExperiment>;
  updateAnalytics(): Promise<IExperiment>;
  clone(newAuthorId: mongoose.Types.ObjectId): Promise<IExperiment>;
  isEditableBy(userId: mongoose.Types.ObjectId): boolean;
  isViewableBy(userId: mongoose.Types.ObjectId): boolean;
}

export interface IChangeLogEntry {
  version: number;
  changes: string[];
  modifiedBy: mongoose.Types.ObjectId;
  modifiedAt: Date;
  summary: string;
}

// å®éªŒè¯„åˆ†æ¥å£
export interface IExperimentRating {
  experimentId: mongoose.Types.ObjectId;
  userId: mongoose.Types.ObjectId;
  rating: number; // 1-5
  review?: string;
  aspects: {
    clarity: number;
    difficulty: number;
    engagement: number;
    usefulness: number;
  };
  createdAt: Date;
  updatedAt: Date;
}

// å®šä¹‰Schema
const ExperimentInstructionSchema = new Schema<IExperimentInstruction>({
  step: { type: Number, required: true },
  title: { type: String, required: true, trim: true },
  content: { type: String, required: true },
  images: [{ type: String }],
  videos: [{ type: String }],
  interactive: { type: Boolean, default: false },
  estimatedTime: { type: Number, min: 0 },
  tips: [{ type: String }],
  warnings: [{ type: String }],
  requirements: [{ type: String }],
  expectedResults: [{ type: String }]
}, { _id: false });

const ExperimentResourceSchema = new Schema<IExperimentResource>({
  id: { type: String, required: true },
  name: { type: String, required: true, trim: true },
  type: { 
    type: String, 
    required: true,
    enum: ['equipment', 'material', 'software', 'document', 'video', 'link']
  },
  description: { type: String, trim: true },
  url: { type: String, trim: true },
  quantity: { type: Number, min: 0 },
  required: { type: Boolean, required: true },
  specifications: { type: Schema.Types.Mixed },
  cost: { type: Number, min: 0 },
  supplier: { type: String, trim: true },
  alternatives: [{ type: String }]
}, { _id: false });

const ExperimentRequirementSchema = new Schema<IExperimentRequirement>({
  type: { 
    type: String, 
    required: true,
    enum: ['knowledge', 'skill', 'equipment', 'software', 'time', 'space']
  },
  description: { type: String, required: true, trim: true },
  level: { 
    type: String, 
    required: true,
    enum: ['basic', 'intermediate', 'advanced']
  },
  optional: { type: Boolean, required: true },
  details: { type: String, trim: true }
}, { _id: false });

const ExperimentMetadataSchema = new Schema<IExperimentMetadata>({
  keywords: [{ type: String, trim: true }],
  academicLevel: [{ type: String, trim: true }],
  subjects: [{ type: String, trim: true }],
  learningOutcomes: [{ type: String, trim: true }],
  assessmentMethods: [{ type: String, trim: true }],
  safetyConsiderations: [{ type: String, trim: true }],
  adaptations: [{ type: String, trim: true }],
  extensions: [{ type: String, trim: true }],
  references: [{ type: String, trim: true }],
  relatedExperiments: [{ type: String, trim: true }]
}, { _id: false });

const StepAnalyticsSchema = new Schema<IStepAnalytics>({
  stepNumber: { type: Number, required: true },
  completionRate: { type: Number, default: 0, min: 0, max: 100 },
  averageTime: { type: Number, default: 0, min: 0 },
  commonErrors: [{ type: String }],
  helpRequests: { type: Number, default: 0, min: 0 },
  skipRate: { type: Number, default: 0, min: 0, max: 100 }
}, { _id: false });

const UserFeedbackSchema = new Schema<IUserFeedback>({
  userId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  rating: { type: Number, required: true, min: 1, max: 5 },
  comment: { type: String, trim: true },
  category: { 
    type: String,
    enum: ['difficulty', 'clarity', 'engagement', 'relevance', 'technical']
  },
  helpful: { type: Boolean, default: false },
  timestamp: { type: Date, default: Date.now }
}, { _id: false });

const PerformanceMetricsSchema = new Schema<IPerformanceMetrics>({
  popularityScore: { type: Number, default: 0, min: 0, max: 100 },
  qualityScore: { type: Number, default: 0, min: 0, max: 100 },
  engagementScore: { type: Number, default: 0, min: 0, max: 100 },
  educationalValue: { type: Number, default: 0, min: 0, max: 100 },
  technicalComplexity: { type: Number, default: 0, min: 0, max: 100 },
  trending: { type: Boolean, default: false },
  featured: { type: Boolean, default: false }
}, { _id: false });

const ExperimentAnalyticsSchema = new Schema<IExperimentAnalytics>({
  totalViews: { type: Number, default: 0, min: 0 },
  totalStarts: { type: Number, default: 0, min: 0 },
  totalCompletions: { type: Number, default: 0, min: 0 },
  averageRating: { type: Number, default: 0, min: 0, max: 5 },
  totalRatings: { type: Number, default: 0, min: 0 },
  averageDuration: { type: Number, default: 0, min: 0 },
  successRate: { type: Number, default: 0, min: 0, max: 100 },
  abandonmentRate: { type: Number, default: 0, min: 0, max: 100 },
  stepAnalytics: [StepAnalyticsSchema],
  userFeedback: [UserFeedbackSchema],
  performanceMetrics: PerformanceMetricsSchema,
  lastAnalyzedAt: { type: Date, default: Date.now }
}, { _id: false });

const ChangeLogEntrySchema = new Schema<IChangeLogEntry>({
  version: { type: Number, required: true },
  changes: [{ type: String, required: true }],
  modifiedBy: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  modifiedAt: { type: Date, default: Date.now },
  summary: { type: String, required: true, trim: true }
}, { _id: false });

// ä¸»å®éªŒSchema
const ExperimentSchema = new Schema<IExperiment>({
  title: { 
    type: String, 
    required: true, 
    trim: true,
    maxlength: 200,
    index: true
  },
  description: { 
    type: String, 
    required: true,
    maxlength: 5000
  },
  shortDescription: { 
    type: String,
    maxlength: 300,
    trim: true
  },
  objectives: [{ 
    type: String, 
    required: true,
    trim: true,
    maxlength: 500
  }],
  instructions: [ExperimentInstructionSchema],
  authorId: { 
    type: Schema.Types.ObjectId, 
    ref: 'User', 
    required: true,
    index: true
  },
  templateId: { 
    type: Schema.Types.ObjectId, 
    ref: 'ExperimentTemplate',
    index: true
  },
  category: { 
    type: String, 
    required: true,
    enum: Object.values(ExperimentCategory),
    index: true
  },
  subcategory: { 
    type: String,
    trim: true,
    index: true
  },
  difficulty: { 
    type: String, 
    required: true,
    enum: Object.values(ExperimentDifficulty),
    index: true
  },
  estimatedDuration: { 
    type: Number, 
    required: true,
    min: 1,
    max: 10080 // æœ€å¤§7å¤©ï¼ˆåˆ†é’Ÿï¼‰
  },
  status: { 
    type: String, 
    required: true,
    enum: Object.values(ExperimentStatus),
    default: ExperimentStatus.DRAFT,
    index: true
  },
  visibility: { 
    type: String, 
    required: true,
    enum: Object.values(ExperimentVisibility),
    default: ExperimentVisibility.PRIVATE,
    index: true
  },
  tags: [{ 
    type: String, 
    trim: true,
    lowercase: true,
    index: true
  }],
  resources: [ExperimentResourceSchema],
  requirements: [ExperimentRequirementSchema],
  metadata: ExperimentMetadataSchema,
  analytics: { 
    type: ExperimentAnalyticsSchema,
    default: () => ({})
  },
  version: { 
    type: Number, 
    default: 1,
    min: 1
  },
  collaborators: [{ 
    type: Schema.Types.ObjectId, 
    ref: 'User',
    index: true
  }],
  reviewers: [{ 
    type: Schema.Types.ObjectId, 
    ref: 'User'
  }],
  publishedAt: { 
    type: Date,
    index: true
  },
  archivedAt: { 
    type: Date,
    index: true
  },
  lastModifiedBy: { 
    type: Schema.Types.ObjectId, 
    ref: 'User',
    required: true
  },
  changeLog: [ChangeLogEntrySchema]
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// ç´¢å¼•å®šä¹‰
ExperimentSchema.index({ title: 'text', description: 'text', 'metadata.keywords': 'text' });
ExperimentSchema.index({ category: 1, difficulty: 1, status: 1 });
ExperimentSchema.index({ authorId: 1, status: 1 });
ExperimentSchema.index({ publishedAt: -1, status: 1 });
ExperimentSchema.index({ 'analytics.averageRating': -1, 'analytics.totalRatings': -1 });
ExperimentSchema.index({ 'analytics.performanceMetrics.popularityScore': -1 });
ExperimentSchema.index({ tags: 1, category: 1 });

// è™šæ‹Ÿå­—æ®µ
ExperimentSchema.virtual('author', {
  ref: 'User',
  localField: 'authorId',
  foreignField: '_id',
  justOne: true
});

ExperimentSchema.virtual('template', {
  ref: 'ExperimentTemplate',
  localField: 'templateId',
  foreignField: '_id',
  justOne: true
});

ExperimentSchema.virtual('sessions', {
  ref: 'ExperimentSession',
  localField: '_id',
  foreignField: 'experimentId'
});

ExperimentSchema.virtual('ratings', {
  ref: 'ExperimentRating',
  localField: '_id',
  foreignField: 'experimentId'
});

// å®ä¾‹æ–¹æ³•
ExperimentSchema.methods.publish = async function(this: IExperiment): Promise<IExperiment> {
  this.status = ExperimentStatus.PUBLISHED;
  this.publishedAt = new Date();
  this.version += 1;
  
  this.changeLog.push({
    version: this.version,
    changes: ['Published experiment'],
    modifiedBy: this.lastModifiedBy,
    modifiedAt: new Date(),
    summary: 'Experiment published'
  });
  
  return this.save();
};

ExperimentSchema.methods.archive = async function(this: IExperiment): Promise<IExperiment> {
  this.status = ExperimentStatus.ARCHIVED;
  this.archivedAt = new Date();
  
  this.changeLog.push({
    version: this.version,
    changes: ['Archived experiment'],
    modifiedBy: this.lastModifiedBy,
    modifiedAt: new Date(),
    summary: 'Experiment archived'
  });
  
  return this.save();
};

ExperimentSchema.methods.addCollaborator = async function(
  this: IExperiment, 
  userId: mongoose.Types.ObjectId
): Promise<IExperiment> {
  if (!this.collaborators.includes(userId)) {
    this.collaborators.push(userId);
    
    this.changeLog.push({
      version: this.version,
      changes: [`Added collaborator: ${userId}`],
      modifiedBy: this.lastModifiedBy,
      modifiedAt: new Date(),
      summary: 'Collaborator added'
    });
  }
  
  return this.save();
};

ExperimentSchema.methods.removeCollaborator = async function(
  this: IExperiment, 
  userId: mongoose.Types.ObjectId
): Promise<IExperiment> {
  this.collaborators = this.collaborators.filter(id => !id.equals(userId));
  
  this.changeLog.push({
    version: this.version,
    changes: [`Removed collaborator: ${userId}`],
    modifiedBy: this.lastModifiedBy,
    modifiedAt: new Date(),
    summary: 'Collaborator removed'
  });
  
  return this.save();
};

ExperimentSchema.methods.updateAnalytics = async function(this: IExperiment): Promise<IExperiment> {
  // è¿™é‡Œå®ç°åˆ†ææ•°æ®æ›´æ–°é€»è¾‘
  this.analytics.lastAnalyzedAt = new Date();
  return this.save();
};

ExperimentSchema.methods.clone = async function(
  this: IExperiment, 
  newAuthorId: mongoose.Types.ObjectId
): Promise<IExperiment> {
  const ExperimentModel = this.constructor as Model<IExperiment>;
  
  const clonedData = this.toObject();
  delete clonedData._id;
  delete clonedData.createdAt;
  delete clonedData.updatedAt;
  
  clonedData.authorId = newAuthorId;
  clonedData.lastModifiedBy = newAuthorId;
  clonedData.title = `${clonedData.title} (å‰¯æœ¬)`;
  clonedData.status = ExperimentStatus.DRAFT;
  clonedData.visibility = ExperimentVisibility.PRIVATE;
  clonedData.publishedAt = undefined;
  clonedData.archivedAt = undefined;
  clonedData.version = 1;
  clonedData.collaborators = [];
  clonedData.reviewers = [];
  clonedData.analytics = {};
  clonedData.changeLog = [{
    version: 1,
    changes: [`Cloned from experiment: ${this._id}`],
    modifiedBy: newAuthorId,
    modifiedAt: new Date(),
    summary: 'Experiment cloned'
  }];
  
  return new ExperimentModel(clonedData).save();
};

ExperimentSchema.methods.isEditableBy = function(
  this: IExperiment, 
  userId: mongoose.Types.ObjectId
): boolean {
  return this.authorId.equals(userId) || 
         this.collaborators.some(id => id.equals(userId));
};

ExperimentSchema.methods.isViewableBy = function(
  this: IExperiment, 
  userId: mongoose.Types.ObjectId
): boolean {
  if (this.visibility === ExperimentVisibility.PUBLIC) {
    return true;
  }
  
  if (this.visibility === ExperimentVisibility.PRIVATE) {
    return this.isEditableBy(userId);
  }
  
  // å…¶ä»–å¯è§æ€§æ£€æŸ¥é€»è¾‘
  return false;
};

// é™æ€æ–¹æ³•
ExperimentSchema.statics.findPublished = function() {
  return this.find({ 
    status: ExperimentStatus.PUBLISHED,
    visibility: { $ne: ExperimentVisibility.PRIVATE }
  });
};

ExperimentSchema.statics.findByCategory = function(category: ExperimentCategory) {
  return this.find({ category, status: ExperimentStatus.PUBLISHED });
};

ExperimentSchema.statics.findFeatured = function() {
  return this.find({ 
    'analytics.performanceMetrics.featured': true,
    status: ExperimentStatus.PUBLISHED
  });
};

// ä¸­é—´ä»¶
ExperimentSchema.pre('save', function(next) {
  if (this.isModified() && !this.isNew) {
    this.version += 1;
  }
  next();
});

ExperimentSchema.pre('remove', function(next) {
  // æ¸…ç†ç›¸å…³æ•°æ®
  // è¿™é‡Œå¯ä»¥æ·»åŠ åˆ é™¤ç›¸å…³ä¼šè¯ã€è¯„åˆ†ç­‰æ•°æ®çš„é€»è¾‘
  next();
});
