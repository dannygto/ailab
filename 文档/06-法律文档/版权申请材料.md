# SSLAB-人工智能辅助实验平台软件著作权申请材料

## 软件全称
SSLAB-人工智能辅助实验平台软件 V1.0

## 软件简称
SSLAB-AI实验平台

## 软件著作权人
[填写著作权人信息]

## 软件开发完成日期
2025年6月24日

## 软件首次发表日期
2025年6月24日

## 软件功能特点及技术特点说明

### 软件功能特点

1. **智能实验辅助功能**
   - 提供基于AI的实验设计辅助，包括实验方案生成与优化
   - 实验过程中的智能问答与指导
   - 实验数据智能分析与结果解释
   - 实验报告生成与修改建议

2. **实验管理功能**
   - 实验创建与模板管理
   - 实验资源分配与管理
   - 实验过程监控与记录
   - 实验结果评估与反馈

3. **数据采集与分析功能**
   - 实验数据自动采集
   - 多维度数据可视化
   - 数据统计分析
   - 实验数据对比与趋势分析

4. **用户管理功能**
   - 多角色用户管理（学生、教师、管理员）
   - 用户权限控制
   - 用户行为分析
   - 个性化设置

5. **系统管理功能**
   - AI模型配置与管理
   - 系统性能监控
   - 数据备份与恢复
   - 系统日志管理

### 技术特点

1. **多模型智能调度技术**
   - 集成多种大型语言模型，包括火山方舟 Doubao-Seed-1.6-thinking 和 DeepSeek Reasoner
   - 基于任务特性的模型选择算法
   - 动态资源分配与负载均衡
   - 模型性能监控与优化

2. **前后端分离架构**
   - 前端基于React、TypeScript和Material-UI构建
   - 后端采用Node.js和Express框架
   - RESTful API设计
   - WebSocket实现实时通信

3. **微服务系统设计**
   - AI服务、实验引擎、图像处理等多个微服务
   - 服务间通信与协同
   - 容器化部署
   - 服务弹性伸缩

4. **数据安全与隐私保护**
   - JWT身份认证
   - 数据传输加密
   - 访问控制与速率限制
   - 敏感信息处理

5. **响应式UI设计**
   - 多设备适配
   - 主题定制
   - 无障碍设计
   - 用户体验优化

## 软件源代码特征性描述

本软件使用TypeScript、JavaScript、Node.js等开发语言，采用前后端分离架构。核心源代码特征如下：

### 前端源代码特征
前端使用React框架开发，采用TypeScript语言，代码组织结构清晰，包含以下主要模块：
- 组件库（components）：包含AI助手、布局、表单等通用组件
- 页面（pages）：包含仪表盘、实验管理、设置等页面组件
- 服务（services）：包含API调用、数据处理等服务
- 状态管理（store）：使用状态管理库维护应用状态
- 类型定义（types）：使用TypeScript接口定义数据结构

### 后端源代码特征
后端使用Node.js和Express框架开发，采用微服务架构，包含以下主要模块：
- AI服务（ai-service）：负责与AI模型交互
- 实验引擎（experiment-engine）：负责实验流程管理
- 图像处理（image-processing）：负责实验图像分析处理
- 通用后端服务：提供基础API支持

### 关键算法特征
- 多模型智能调度算法：基于任务特性和模型能力的匹配算法
- 实验数据分析算法：用于处理和分析实验数据的统计和机器学习算法
- 资源调度算法：优化实验资源分配的算法

## 软件登记材料形式

1. 源程序（源代码）
   - 前端源代码：React组件、服务、状态管理等
   - 后端源代码：API服务、中间件、数据处理等
   - 配置文件：环境配置、项目配置等

2. 可执行程序
   - 前端构建包
   - 后端服务程序
   - Docker容器配置

3. 软件说明文档
   - 系统设计文档
   - API文档
   - 用户使用手册
   - 部署指南

## 源代码

本节包含SSLAB-AI实验平台软件的核心代码文件，按照软件著作权申请要求，提供前30页和后30页完整源代码。

### 前30页源代码

#### 文件1: backend/src/server.ts - 后端主服务器（开始部分）
```typescript
```typescript
/**
 * 🚀 后端主服务器 - 完成度: 96%
 * 
 * ✅ 已完成功能:
 * - Express应用框架配置
 * - WebSocket实时通信服务
 * - RESTful API路由系统
 * - 跨域CORS配置
 * - 安全中间件(Helmet)
 * - 请求日志记录(Morgan)
 * - AI助手服务集成
 * - 设备管理API
 * - 模板管理API
 * - 指导系统API
 * - 错误处理中间件
 * 
 * 🔄 待完善功能:
 * - 数据库连接池优化
 * - 更多业务API接口
 * - 文件上传处理
 * - 缓存机制集成
 * 
 * 📊 技术亮点:
 * - TypeScript类型安全
 * - 微服务架构设计
 * - 实时双向通信
 * - 模块化路由管理
 * - 环境配置管理
 */

import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import { Server as WebSocketServer } from 'ws';
import http from 'http';
import dotenv from 'dotenv';
import { aiService } from './services/ai.service';
import guidanceRoutes from './routes/guidance.routes';
import deviceRoutes from './routes/device.routes';
import templateRoutes from './routes/template.routes';

// 加载环境变量
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3002;

// 创建HTTP服务器
const server = http.createServer(app);

// 设置WebSocket服务器
const wss = new WebSocketServer({ server, path: '/ws' });

// WebSocket连接处理
wss.on('connection', (ws) => {
  console.log('WebSocket客户端已连接');
  
  // 发送初始连接成功消息
  ws.send(JSON.stringify({ 
    type: 'connection',
    status: 'connected',
    message: 'WebSocket连接已建立',
    timestamp: new Date().toISOString()
  }));
  
  // 监听客户端消息
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message.toString());
      console.log('收到WebSocket消息:', data);
      
      // 根据消息类型处理
      if (data.type === 'ping') {
        ws.send(JSON.stringify({
          type: 'pong',
          timestamp: new Date().toISOString()
        }));
      } else if (data.type === 'ai-request') {
        // 模拟AI处理
        setTimeout(() => {
          ws.send(JSON.stringify({
            type: 'ai-response',
            requestId: data.requestId,
            message: '这是来自AI助手的响应',
            timestamp: new Date().toISOString()
          }));
        }, 1000);
      }
    } catch (err) {
      console.error('处理WebSocket消息时出错:', err);
      ws.send(JSON.stringify({ 
        type: 'error',
        message: '消息格式错误',
        timestamp: new Date().toISOString()
      }));
    }
  });
  
  // 处理连接关闭
  ws.on('close', () => {
    console.log('WebSocket客户端已断开连接');
  });
  
  // 处理错误
  ws.on('error', (error) => {
    console.error('WebSocket错误:', error);
  });
});

// 安全中间件
app.use(helmet());

// CORS配置 - 修复前端端口为3000
app.use(cors({
  origin: [
    process.env.FRONTEND_URL || "http://localhost:3000", 
    "http://localhost:3001", // 备用端口
    "http://192.168.0.145:3000",
    "http://192.168.0.145:3001"
  ],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
}));

// 请求日志
app.use(morgan('combined'));

// JSON解析
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// 基础路由
app.get('/', (req, res) => {
  res.json({ 
    message: '人工智能辅助实验平台后端API - 普教版',
    version: '1.0.0',
    edition: 'basic',
    timestamp: new Date().toISOString()
  });
});

// 健康检查
app.get('/health', (req, res) => {
  res.json({ 
    status: 'healthy',
    timestamp: new Date().toISOString()
  });
});

// API健康检查
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'healthy',
    timestamp: new Date().toISOString()
  });
});

// AI助手模型测试连接端点
app.post('/api/ai-assistant/test-connection', (req, res) => {
  try {
    const { model, config, specificParams } = req.body;

    console.log(`🧪 测试AI模型连接: ${model}`);

    // 在这里我们只是验证请求格式，实际环境中应该尝试实际连接模型API
    if (!model || !config || !config.apiKey) {
      return res.status(400).json({
        success: false,
        message: '缺少必要参数: 模型名称或API密钥'
      });
    }

    // 根据不同的模型返回不同的token限制信息
    let tokenLimits = {};
    if (model === 'doubao-seed-1-6-thinking-250615') {
      tokenLimits = {
        contextWindow: 256000,
        inputTokenLimit: 240000,
        outputTokenLimit: 16000
      };
    } else if (model === 'deepseek-reasoner') {
      tokenLimits = {
        contextWindow: 128000, 
        inputTokenLimit: 120000,
        outputTokenLimit: 8000
      };
    } else {
      tokenLimits = {
        contextWindow: 32000,
        inputTokenLimit: 30000,
        outputTokenLimit: 2000
      };
    }

    // 模拟成功响应
    return res.json({
      success: true,
      message: `成功连接到 ${model}`,
      tokenLimits
    });
  } catch (error: any) {
    console.error('AI模型连接测试失败:', error);
    return res.status(500).json({
      success: false,
      message: error.message || 'AI模型连接测试失败'
    });
  }
});

// 仪表盘最近实验
app.get('/api/dashboard/recent-experiments', (req, res) => {
  const limit = parseInt(req.query.limit as string) || 5;
  
  const experiments = [
    {
      id: '1',
      name: '磁铁性质探究',
      description: '观察磁铁的吸引力和磁极性质，探究磁铁在日常生活中的应用',
      type: 'observation',
      status: 'completed',
      userId: '1',
      createdAt: '2025-06-20T10:00:00Z',
      updatedAt: '2025-06-20T11:30:00Z'
    },
    {
      id: '2',
      name: '植物光合作用观察',
      description: '通过设计实验，观察不同光照条件下植物的光合作用速率变化',
      type: 'observation',
      status: 'running',
      userId: '2',
      createdAt: '2025-06-21T09:00:00Z',
      updatedAt: '2025-06-21T09:30:00Z'
    },
    {
      id: '3',
      name: '水的电解实验',
      description: '通过电解水，研究水分子的组成和化学反应过程',
      type: 'chemical',
      status: 'completed',
      userId: '1',
      createdAt: '2025-06-19T14:00:00Z',
      updatedAt: '2025-06-19T15:30:00Z'
    },
    {
      id: '4',
      name: '声音传播实验',
      description: '研究声音在不同介质中的传播特性',
      type: 'physics',
      status: 'failed',
      userId: '3',
      createdAt: '2025-06-18T13:00:00Z',
      updatedAt: '2025-06-18T14:00:00Z'
    },
    {
      id: '5',
      name: '重力加速度测量',
      description: '使用自由落体实验测量重力加速度',
      type: 'physics',
      status: 'completed',
      userId: '2',
      createdAt: '2025-06-17T10:00:00Z',
      updatedAt: '2025-06-17T11:00:00Z'
    }
  ];
  
  res.json(experiments.slice(0, limit));
});

#### 文件2: backend/src/services/ai.service.ts - AI服务模块
```typescript
import axios from 'axios';

// AI模型配置接口
export interface AIModelConfig {
  id: string;
  name: string;
  provider: string;
  endpoint: string;
  apiKey?: string;
  available: boolean;
  maxTokens: number;
  temperature: number;
  description: string;
}

// 聊天消息接口
export interface ChatMessage {
  role: 'system' | 'user' | 'assistant';
  content: string | Array<{
    type: 'text' | 'image_url';
    text?: string;
    image_url?: {
      url: string;
    };
  }>;
}

// AI响应接口
export interface AIResponse {
  content: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  model: string;
  finishReason?: string;
}

export class AIService {
  private models: Map<string, AIModelConfig> = new Map();

  constructor() {
    this.initializeModels();
  }

  private initializeModels() {
    // 火山方舟 - 豆包模型
    this.models.set('doubao-seed', {
      id: 'doubao-seed',
      name: '豆包 (火山方舟)',
      provider: '火山方舟',
      endpoint: 'https://ark.cn-beijing.volces.com/api/v3/chat/completions',
      apiKey: process.env.ARK_API_KEY,
      available: !!process.env.ARK_API_KEY,
      maxTokens: 4096,
      temperature: 0.7,
      description: '字节跳动豆包大模型，支持中文对话和多模态'
    });

    // DeepSeek 模型
    this.models.set('deepseek-chat', {
      id: 'deepseek-chat',
      name: 'DeepSeek Chat',
      provider: 'DeepSeek',
      endpoint: 'https://api.deepseek.com/chat/completions',
      apiKey: process.env.DEEPSEEK_API_KEY,
      available: !!process.env.DEEPSEEK_API_KEY,
      maxTokens: 4096,
      temperature: 0.7,
      description: 'DeepSeek 深度求索大模型，擅长推理和编程'
    });
  }

  // 获取可用模型列表
  public getAvailableModels(): AIModelConfig[] {
    return Array.from(this.models.values()).filter(model => model.available);
  }

  // 获取指定模型配置
  public getModelConfig(modelId: string): AIModelConfig | undefined {
    return this.models.get(modelId);
  }

  // 火山方舟API调用
  private async callVolcanicArk(
    messages: ChatMessage[],
    config: AIModelConfig
  ): Promise<AIResponse> {
    try {
      const response = await axios.post(
        config.endpoint,
        {
          model: 'doubao-seed-1-6-thinking-250615',
          messages: messages,
          max_tokens: config.maxTokens,
          temperature: config.temperature,
          stream: false
        },
        {
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${config.apiKey}`
          },
          timeout: 30000
        }
      );

      const data = response.data;
      return {
        content: data.choices[0].message.content,
        usage: data.usage ? {
          promptTokens: data.usage.prompt_tokens,
          completionTokens: data.usage.completion_tokens,
          totalTokens: data.usage.total_tokens
        } : undefined,
        model: config.id,
        finishReason: data.choices[0].finish_reason
      };
    } catch (error: any) {
      console.error('火山方舟API调用失败:', error.response?.data || error.message);
      throw new Error(`火山方舟API调用失败: ${error.response?.data?.error?.message || error.message}`);
    }
  }

  // DeepSeek API调用
  private async callDeepSeek(
    messages: ChatMessage[],
    config: AIModelConfig
  ): Promise<AIResponse> {
    try {
      const response = await axios.post(
        config.endpoint,
        {
          model: 'deepseek-chat',
          messages: messages,
          max_tokens: config.maxTokens,
          temperature: config.temperature,
          stream: false
        },
        {
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${config.apiKey}`
          },
          timeout: 30000
        }
      );

      const data = response.data;
      return {
        content: data.choices[0].message.content,
        usage: data.usage ? {
          promptTokens: data.usage.prompt_tokens,
          completionTokens: data.usage.completion_tokens,
          totalTokens: data.usage.total_tokens
        } : undefined,
        model: config.id,
        finishReason: data.choices[0].finish_reason
      };
    } catch (error: any) {
      console.error('DeepSeek API调用失败:', error.response?.data || error.message);
      throw new Error(`DeepSeek API调用失败: ${error.response?.data?.error?.message || error.message}`);
    }
  }

  // 主要聊天接口
  public async chat(
    messages: ChatMessage[],
    modelId: string = 'deepseek-chat',
    options?: {
      temperature?: number;
      maxTokens?: number;
    }
  ): Promise<AIResponse> {
    const model = this.getModelConfig(modelId);
    
    if (!model) {
      throw new Error(`模型 ${modelId} 不存在`);
    }

    if (!model.available) {
      throw new Error(`模型 ${modelId} 不可用，请检查API密钥配置`);
    }

    // 应用选项参数
    const effectiveConfig = {
      ...model,
      temperature: options?.temperature ?? model.temperature,
      maxTokens: options?.maxTokens ?? model.maxTokens
    };

    // 根据不同提供商调用相应的API
    switch (model.provider) {
      case '火山方舟':
        return await this.callVolcanicArk(messages, effectiveConfig);
      case 'DeepSeek':
        return await this.callDeepSeek(messages, effectiveConfig);
      default:
        throw new Error(`不支持的AI提供商: ${model.provider}`);
    }
  }

  // 生成文本 (兼容旧接口)
  public async generateText(
    modelId: string,
    messages: ChatMessage[],
    options?: {
      temperature?: number;
      maxTokens?: number;
    }
  ): Promise<AIResponse> {
    return await this.chat(messages, modelId, options);
  }

  // 测试连接 (兼容旧接口)
  public async testConnection(aiConfig: {
    selectedModel: string;
    apiKey: string;
    temperature?: number;
    maxTokens?: number;
  }): Promise<{ success: boolean; message: string }> {
    try {
      // 临时更新API密钥
      const model = this.getModelConfig(aiConfig.selectedModel);
      if (!model) {
        return {
          success: false,
          message: `模型 ${aiConfig.selectedModel} 不存在`
        };
      }

      const tempModel: AIModelConfig = {
        ...model,
        apiKey: aiConfig.apiKey,
        available: true,
        temperature: aiConfig.temperature || model.temperature,
        maxTokens: aiConfig.maxTokens || model.maxTokens
      };

      const testMessages: ChatMessage[] = [
        {
          role: 'user',
          content: '你好，请简单回复一下确认连接正常。'
        }
      ];

      // 根据不同提供商调用相应的API
      let response: AIResponse;
      switch (model.provider) {
        case '火山方舟':
          response = await this.callVolcanicArk(testMessages, tempModel);
          break;
        case 'DeepSeek':
          response = await this.callDeepSeek(testMessages, tempModel);
          break;
        default:
          return {
            success: false,
            message: `不支持的AI提供商: ${model.provider}`
          };
      }
      
      return {
        success: true,
        message: `模型 ${aiConfig.selectedModel} 连接成功，响应: ${response.content.substring(0, 50)}...`
      };
    } catch (error: any) {
      return {
        success: false,
        message: `模型 ${aiConfig.selectedModel} 连接失败: ${error.message}`
      };
    }
  }
}

// 导出单例实例
export const aiService = new AIService();

#### 文件3: frontend/src/App.tsx - 前端主应用
```tsx
import React, { useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import { CssBaseline, Box } from '@mui/material';
import { Toaster } from 'react-hot-toast';
import { QueryClient, QueryClientProvider } from 'react-query';
import { HelmetProvider } from 'react-helmet-async';
import { ErrorBoundary } from 'react-error-boundary';

// 导入组件
import MainLayout from './components/layout/MainLayout';
import PWAPrompt from './components/common/PWAPrompt';

// 导入页面
import Dashboard from './pages/Dashboard';
import Login from './pages/Login';
import Register from './pages/Register';
import ExperimentList from './pages/experiments/ExperimentList';
import ExperimentDetail from './pages/experiments/ExperimentDetail';
import ExperimentCreate from './pages/experiments/ExperimentCreate';
import TemplateLibrary from './pages/templates/TemplateLibrary';
import TemplateDetail from './pages/templates/TemplateDetail';
import TemplateCreate from './pages/templates/TemplateCreate';
import AIAssistant from './pages/AIAssistant';
import ApiIntegrationCheck from './pages/ApiIntegrationCheck';
import ResourceManagement from './pages/resources/ResourceManagement';
import DataCollectionAnalysis from './pages/data/DataCollectionAnalysis';
import GuidanceSystem from './pages/guidance/GuidanceSystem';
import DeviceManagement from './pages/devices/DeviceManagement';
// import ImageProcessing from './pages/ImageProcessing';
// import Templates from './pages/Templates';
// import Analytics from './pages/Analytics';
// import Users from './pages/Users';
import Settings from './pages/Settings';
// import Profile from './pages/Profile';
import Help from './pages/Help';
// import About from './pages/About';

// 创建React Query客户端
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
});

// 错误边界组件
const ErrorFallback: React.FC<{ error: Error; resetErrorBoundary: () => void }> = ({
  error,
  resetErrorBoundary,
}) => {
  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        minHeight: '100vh',
        p: 3,
      }}
    >
      <h2>出现了一些问题</h2>
      <pre style={{ color: 'red' }}>{error.message}</pre>
      <button onClick={resetErrorBoundary}>重试</button>
    </Box>
  );
};

// 受保护的路由组件
const ProtectedRoute: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { isAuthenticated } = useUserStore();

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

// 返回并退出
  return <>{children}</>;
};

const App: React.FC = () => {
  const { theme: appTheme } = useThemeStore();

  // 创建主题
  const theme = createTheme({
    palette: {
      mode: appTheme.mode,
      primary: {
        main: appTheme.primaryColor,
      },
      secondary: {
        main: appTheme.secondaryColor,
      },
      background: {
        default: appTheme.backgroundColor,
        paper: appTheme.mode === 'dark' ? '#1e1e1e' : '#ffffff',
      },
      text: {
        primary: appTheme.textColor,
      },
    },
    typography: {
      fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
      h1: {
        fontSize: '2.5rem',
        fontWeight: 600,
      },
      h2: {
        fontSize: '2rem',
        fontWeight: 600,
      },

#### 文件4: frontend/src/services/api.ts - 前端API服务模块（第一部分）
```typescript
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { toast } from 'react-hot-toast';

// API响应接口
export interface ApiResponse<T = any> {
  success: boolean;
  data: T;
  message: string;
  code: number;
  timestamp: string;
}

// 分页响应接口
export interface PaginatedResponse<T> {
  items: T[];
  total: number;
  page: number;
  pageSize: number;
  totalPages: number;
}

// API服务类
class ApiService {
  private apiClient: AxiosInstance;
  private baseURL: string;

  constructor() {
    // 根据环境确定API基础URL
    this.baseURL = process.env.REACT_APP_API_URL || 'http://localhost:3002/api';
    
    // 创建axios实例
    this.apiClient = axios.create({
      baseURL: this.baseURL,
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json',
      }
    });

    // 配置请求拦截器
    this.apiClient.interceptors.request.use(
      (config) => {
        // 添加认证token
        const token = localStorage.getItem('token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        
        // 添加请求ID和时间戳
        const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        config.headers['X-Request-ID'] = requestId;
        config.headers['X-Timestamp'] = new Date().toISOString();

        return config;
      },
      (error) => {
        console.error('请求拦截器错误:', error);
        return Promise.reject(error);
      }
    );

    // 配置响应拦截器
    this.apiClient.interceptors.response.use(
      (response) => {
        return response;
      },
      (error) => {
        this.handleError(error);
        return Promise.reject(error);
      }
    );
  }

  // 错误处理
  private handleError(error: any): void {
    if (error.response) {
      const { status, data } = error.response;
      
      switch (status) {
        case 401:
          // 未授权，清除token并重定向到登录页
          localStorage.removeItem('token');
          localStorage.removeItem('user');
          
          if (window.location.pathname !== '/login') {
            toast.error('会话已过期，请重新登录');
            window.location.href = '/login';
          }
          break;
        case 403:
          toast.error('您没有权限执行此操作');
          break;
        case 404:
          // API检查时的404错误静默处理
          if (error.config?.url?.includes('health') || 
              error.config?.url?.includes('chat') ||
              error.config?.url?.includes('auth/me')) {
            console.warn(`⚠️ API端点 ${error.config.url} 不存在，使用降级模式`);
            return;
          }
          toast.error('请求的资源不存在');
          break;
        case 500:
          toast.error('服务器内部错误');
          break;
        default:
          // 对于API检查相关的错误，降低提示级别
          if (error.config?.url?.includes('health') || 
              error.config?.url?.includes('chat')) {
            console.warn(`⚠️ API响应异常: ${data?.message || '服务暂时不可用'}`);
            return;
          }
          toast.error(data?.message || '请求失败');
      }
    } else {
      console.error('请求配置错误:', error.message);
    }
  }

  // 通用请求方法
  private async request<T>(config: AxiosRequestConfig): Promise<T> {
    try {
      const response: AxiosResponse<ApiResponse<T>> = await this.apiClient.request(config);
      return response.data.data as T;
    } catch (error) {
      throw error;
    }
  }

  // 通用HTTP方法
  async get<T = any>(url: string, params?: any): Promise<T> {
    return this.request<T>({
      method: 'GET',
      url,
      params,
    });
  }

  async post<T = any>(url: string, data?: any, config?: Partial<AxiosRequestConfig>): Promise<T> {
    return this.request<T>({
      method: 'POST',
      url,
      data,
      ...config,
    });
  }

  async put<T = any>(url: string, data?: any): Promise<T> {
    return this.request<T>({
      method: 'PUT',
      url,
      data,
    });
  }

  async delete<T = any>(url: string, params?: any): Promise<T> {
    return this.request<T>({
      method: 'DELETE',
      url,
      params,
    });
  }

  async patch<T = any>(url: string, data?: any): Promise<T> {
    return this.request<T>({
      method: 'PATCH',
      url,
      data,
    });
  }

  // 健康检查API
  async checkHealth(): Promise<{ status: string; version: string }> {
    try {
      return await this.get('/health');
    } catch (error) {
      console.warn('健康检查失败:', error);
      return { status: 'unhealthy', version: 'unknown' };
    }
  }

  // AI助手API
  async testAIConnection(modelConfig: {
    selectedModel: string;
    apiKey: string;
    temperature?: number;
    maxTokens?: number;
  }): Promise<{ success: boolean; message: string; tokenLimits?: any }> {
    try {
      const response = await this.post('/ai-assistant/test-connection', {
        model: modelConfig.selectedModel,
        config: {
          apiKey: modelConfig.apiKey,
          temperature: modelConfig.temperature || 0.7,
          maxTokens: modelConfig.maxTokens || 2000
        }
      });
      return response;
    } catch (error: any) {
      return {
        success: false,
        message: error.response?.data?.message || '连接测试失败'
      };
    }
  }
}

// 创建API服务实例
const apiService = new ApiService();
export default apiService;

#### 文件5: frontend/src/pages/settings/AIModelSettings.tsx - AI模型设置页面
```tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Paper,
  Typography,
  Grid,
  Card,
  CardContent,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  TextField,
  Button,
  Chip,
  Alert,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  List,
  ListItem,
  ListItemText,
  ListItemIcon
} from '@mui/material';

import {
  ExpandMore as ExpandMoreIcon,
  Settings as SettingsIcon,
  Check as CheckIcon,
  Error as ErrorIcon,
  Info as InfoIcon,
  Security as SecurityIcon
} from '@mui/icons-material';

import { AI_MODELS, AI_PROVIDERS, DEFAULT_AI_CONFIG } from '../../config/ai-models';
import apiService from '../../services/api';

interface AIConfig {
  selectedModel: string;
  apiKey: string;
  temperature: number;
  maxTokens: number;
  systemPrompt: string;
  customEndpoint?: string;
}

const AIModelSettings: React.FC = () => {
  const [config, setConfig] = useState<AIConfig>(DEFAULT_AI_CONFIG);
  const [selectedProvider, setSelectedProvider] = useState<string>('火山方舟'); // 默认火山方舟，对应默认模型
  const [testResult, setTestResult] = useState<{ success: boolean; message: string } | null>(null);
  const [isTesting, setIsTesting] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [tokenLimits, setTokenLimits] = useState<any>(null);
  const [providerModels, setProviderModels] = useState<any[]>([]);

  // 载入保存的配置
  useEffect(() => {
    loadSavedConfig();
  }, []);

  // 根据选择的提供商更新可用模型
  useEffect(() => {
    updateProviderModels();
  }, [selectedProvider]);

  // 载入保存的配置
  const loadSavedConfig = () => {
    try {
      const savedConfig = localStorage.getItem('ai_config');
      if (savedConfig) {
        const parsedConfig = JSON.parse(savedConfig);
        setConfig(parsedConfig);
        
        // 确定提供商
        const model = AI_MODELS.find(m => m.id === parsedConfig.selectedModel);
        if (model) {
          setSelectedProvider(model.provider);
        }
      }
    } catch (error) {
      console.error('载入AI配置失败:', error);
    }
  };

  // 更新提供商模型列表
  const updateProviderModels = () => {
    const models = AI_MODELS.filter(model => model.provider === selectedProvider);
    setProviderModels(models);
    
    // 如果当前选择的模型不属于当前提供商，则自动选择该提供商的第一个模型
    const currentModelBelongsToProvider = models.some(m => m.id === config.selectedModel);
    if (!currentModelBelongsToProvider && models.length > 0) {
      handleChange('selectedModel')(models[0].id);
    }
  };

  // 处理输入变化
  const handleChange = (prop: keyof AIConfig) => (event: any) => {
    const value = event.target.value;
    setConfig({ ...config, [prop]: value });
    
    // 如果更改了模型，检查并更新提供商
    if (prop === 'selectedModel') {
      const model = AI_MODELS.find(m => m.id === value);
      if (model && model.provider !== selectedProvider) {
        setSelectedProvider(model.provider);
      }
    }
    
    // 清除测试结果
    setTestResult(null);
  };

  // 处理提供商变更
  const handleProviderChange = (event: any) => {
    const newProvider = event.target.value;
    setSelectedProvider(newProvider);
    
    // 清除测试结果
    setTestResult(null);
  };

  // 保存配置
  const saveConfig = () => {
    try {
      setIsSaving(true);
      localStorage.setItem('ai_config', JSON.stringify(config));
      
      // 显示保存成功
      setTimeout(() => {
        setIsSaving(false);
        toast.success('AI模型配置已保存');
      }, 500);
    } catch (error) {
      console.error('保存AI配置失败:', error);
      setIsSaving(false);
      toast.error('保存配置失败');
    }
  };

  // 测试连接
  const testConnection = async () => {
    try {
      setIsTesting(true);
      setTestResult(null);
      
      const result = await apiService.testAIConnection({
        selectedModel: config.selectedModel,
        apiKey: config.apiKey,
        temperature: config.temperature,
        maxTokens: config.maxTokens
      });
      
      setTestResult(result);
      if (result.tokenLimits) {
        setTokenLimits(result.tokenLimits);
      }
    } catch (error) {
      console.error('测试连接失败:', error);
      setTestResult({
        success: false,
        message: '测试连接失败，请检查网络连接'
      });
    } finally {
      setIsTesting(false);
    }
  };

  return (
    <Box sx={{ py: 3 }}>
      <Typography variant="h4" gutterBottom>
        <SettingsIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
        AI模型设置
      </Typography>
      
      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="subtitle1" gutterBottom>
          配置AI模型连接和参数，用于实验设计、数据分析和智能辅助功能
        </Typography>
        
        <Grid container spacing={3} sx={{ mt: 2 }}>
          {/* AI提供商选择 */}
          <Grid item xs={12} md={6}>
            <FormControl fullWidth>
              <InputLabel>AI提供商</InputLabel>
              <Select
                value={selectedProvider}
                onChange={handleProviderChange}
                label="AI提供商"
              >
                {AI_PROVIDERS.map((provider) => (
                  <MenuItem key={provider.id} value={provider.id}>
                    {provider.name}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>

          {/* 模型选择 */}
          <Grid item xs={12} md={6}>
            <FormControl fullWidth>
              <InputLabel>AI模型</InputLabel>
              <Select
                value={config.selectedModel}
                onChange={handleChange('selectedModel')}
                label="AI模型"
              >
                {providerModels.map((model) => (
                  <MenuItem key={model.id} value={model.id}>
                    {model.name}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>

### 后30页源代码

#### 文件1: frontend/src/types/index.ts - 类型定义系统（开始部分）
```typescript
// 基础类型定义
export interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

// 用户相关类型
export interface User extends BaseEntity {
  username: string;
  email: string;
  displayName: string;
  role: UserRole;
  status: UserStatus;
  avatar?: string;
  lastLoginAt?: Date;
  metadata?: Record<string, any>;
}

export enum UserRole {
  ADMIN = 'admin',
  TEACHER = 'teacher',
  STUDENT = 'student',
  GUEST = 'guest'
}

export enum UserStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  SUSPENDED = 'suspended',
  PENDING = 'pending'
}

// 实验相关类型
export interface Experiment extends BaseEntity {
  title: string;
  description: string;
  authorId: string;
  templateId?: string;
  status: ExperimentStatus;
  category: string;
  tags: string[];
  objectives: string[];
  instructions: ExperimentInstruction[];
  materials: ExperimentMaterial[];
  results: ExperimentResult[];
  visibility: ExperimentVisibility;
  featuredImageUrl?: string;
  estimatedDuration: number; // 分钟
  difficulty: ExperimentDifficulty;
  metadata?: Record<string, any>;
}

export interface ExperimentInstruction {
  step: number;
  title: string;
  content: string;
  imageUrls?: string[];
  videoUrl?: string;
  duration?: number; // 估计分钟数
  note?: string;
}

export interface ExperimentMaterial {
  id: string;
  name: string;
  description?: string;
  quantity: number;
  unit?: string;
  type: MaterialType;
  imageUrl?: string;
  link?: string;
}

export enum MaterialType {
  EQUIPMENT = 'equipment',
  CHEMICAL = 'chemical',
  BIOLOGICAL = 'biological',
  TOOL = 'tool',
  OTHER = 'other'
}

export interface ExperimentResult {
  id: string;
  title: string;
  description: string;
  type: ResultType;
  data?: any;
  imageUrls?: string[];
  createdAt: Date;
  createdBy: string;
}

export enum ResultType {
  MEASUREMENT = 'measurement',
  OBSERVATION = 'observation',
  CALCULATION = 'calculation',
  CONCLUSION = 'conclusion'
}

export enum ExperimentStatus {
  DRAFT = 'draft',
  ACTIVE = 'active',
  ARCHIVED = 'archived',
  PENDING_REVIEW = 'pending_review',
  DELETED = 'deleted'
}

export enum ExperimentVisibility {
  PUBLIC = 'public',
  PRIVATE = 'private',
  ORGANIZATION = 'organization'
}

export enum ExperimentDifficulty {
  BEGINNER = 'beginner',
  INTERMEDIATE = 'intermediate',
  ADVANCED = 'advanced',
  EXPERT = 'expert'
}

// 模板相关类型
export interface ExperimentTemplate extends BaseEntity {
  title: string;
  description: string;
  authorId: string;
  category: string;
  tags: string[];
  featuredImageUrl?: string;
  structure: ExperimentTemplateStructure;
  popularity: number;
  usageCount: number;
  rating: number;
  visibility: ExperimentVisibility;
  metadata?: Record<string, any>;
}

export interface ExperimentTemplateStructure {
  instructions: ExperimentInstruction[];
  materials: ExperimentMaterial[];
  objectives: string[];
  estimatedDuration: number;
  difficulty: ExperimentDifficulty;
}

// AI助手相关类型
export interface ChatMessage {
  id: string;
  role: 'system' | 'user' | 'assistant';
  content: string;
  timestamp: Date;
  metadata?: Record<string, any>;
}

export interface ChatSession {
  id: string;
  userId: string;
  title: string;
  messages: ChatMessage[];
  modelId: string;
  createdAt: Date;
  updatedAt: Date;
  metadata?: Record<string, any>;
}

export interface AIAssistantResponse {
  content: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  model: string;
  finishReason?: string;
}

// 设备相关类型
export interface Device extends BaseEntity {
  name: string;
  type: DeviceType;
  status: DeviceStatus;
  ipAddress?: string;
  location?: string;
  description?: string;
  specifications?: Record<string, any>;
  firmwareVersion?: string;
  lastMaintenance?: Date;
  nextMaintenance?: Date;
  ownerId: string;
  metadata?: Record<string, any>;
}

export enum DeviceType {
  SENSOR = 'sensor',
  CAMERA = 'camera',
  ACTUATOR = 'actuator',
  CONTROL_SYSTEM = 'control_system',
  MEASUREMENT = 'measurement',
  COMPUTER = 'computer',
  OTHER = 'other'
}

export enum DeviceStatus {
  ONLINE = 'online',
  OFFLINE = 'offline',
  MAINTENANCE = 'maintenance',
  ERROR = 'error',
  RESERVED = 'reserved'
}

export interface DeviceDataPoint {
  deviceId: string;
  timestamp: Date;
  value: number | string | boolean;
  type: string;
  unit?: string;
  metadata?: Record<string, any>;
}

export interface DeviceCommand {
  id: string;
  deviceId: string;
  command: string;
  parameters?: Record<string, any>;
  status: CommandStatus;
  createdAt: Date;
  executedAt?: Date;
  result?: Record<string, any>;
}

export enum CommandStatus {
  PENDING = 'pending',
  EXECUTING = 'executing',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELLED = 'cancelled'
}

export interface DeviceReservation {
  id: string;
  deviceId: string;
  userId: string;
  startTime: Date;
  endTime: Date;
  purpose: string;
  status: ReservationStatus;
  notes?: string;
}

export enum ReservationStatus {
  PENDING = 'pending',
  CONFIRMED = 'confirmed',
  CANCELLED = 'cancelled',
  COMPLETED = 'completed'
}

// 查询参数类型
export interface GetDevicesParams {
  type?: DeviceType;
  status?: DeviceStatus;
  location?: string;
  ownerId?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface GetDeviceDataParams {
  deviceId: string;
  startDate?: Date;
  endDate?: Date;
  type?: string;
  limit?: number;
  aggregation?: 'none' | 'hourly' | 'daily' | 'weekly';
}

export interface SendDeviceCommandParams {
  deviceId: string;
  command: string;
  parameters?: Record<string, any>;
  priority?: 'low' | 'normal' | 'high';
}

export interface CreateDeviceReservationParams {
  deviceId: string;
  startTime: Date;
  endTime: Date;
  purpose: string;
  notes?: string;
}

export interface GetDeviceReservationsParams {
  deviceId?: string;
  userId?: string;
  status?: ReservationStatus;
  startTime?: Date;
  endTime?: Date;
  page?: number;
  limit?: number;
}

export interface DeviceMonitoringData {
  deviceId: string;
  status: DeviceStatus;
  metrics: {
    cpu?: number;
    memory?: number;
    diskSpace?: number;
    temperature?: number;
    battery?: number;
  };
  lastHeartbeat: Date;
  alerts: Array<{
    type: string;
    message: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    timestamp: Date;
  }>;
}

#### 文件2: backend/src/controllers/device.controller.ts - 设备控制器
```typescript
import { Request, Response } from 'express';
import { DeviceService } from '../services/device.service';
import { validateSchema } from '../middleware/validation';
import { DeviceSchema, DeviceQuerySchema } from '../schemas/device.schema';

export class DeviceController {
  private deviceService: DeviceService;

  constructor() {
    this.deviceService = new DeviceService();
  }

  /**
   * 获取所有设备
   */
  public getAllDevices = async (req: Request, res: Response): Promise<void> => {
    try {
      // 验证查询参数
      const validatedQuery = validateSchema(DeviceQuerySchema, req.query);
      
      // 获取设备
      const devices = await this.deviceService.getAllDevices(validatedQuery);
      
      res.status(200).json({
        success: true,
        data: devices,
        message: '成功获取设备列表',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || '获取设备列表失败',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * 获取设备详情
   */
  public getDeviceById = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      
      // 获取设备
      const device = await this.deviceService.getDeviceById(id);
      
      res.status(200).json({
        success: true,
        data: device,
        message: '成功获取设备详情',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || '获取设备详情失败',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * 创建设备
   */
  public createDevice = async (req: Request, res: Response): Promise<void> => {
    try {
      // 验证请求数据
      const validatedData = validateSchema(DeviceSchema, req.body);
      
      // 创建设备
      const device = await this.deviceService.createDevice({
        ...validatedData,
        ownerId: req.user.id // 从认证中间件获取用户ID
      });
      
      res.status(201).json({
        success: true,
        data: device,
        message: '成功创建设备',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || '创建设备失败',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * 更新设备
   */
  public updateDevice = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      
      // 验证请求数据
      const validatedData = validateSchema(DeviceSchema, req.body, { partial: true });
      
      // 更新设备
      const device = await this.deviceService.updateDevice(id, validatedData);
      
      res.status(200).json({
        success: true,
        data: device,
        message: '成功更新设备',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || '更新设备失败',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * 删除设备
   */
  public deleteDevice = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      
      // 删除设备
      await this.deviceService.deleteDevice(id);
      
      res.status(200).json({
        success: true,
        message: '成功删除设备',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || '删除设备失败',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * 获取设备数据
   */
  public getDeviceData = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const { startDate, endDate, type, limit, aggregation } = req.query;
      
      // 获取设备数据
      const data = await this.deviceService.getDeviceData({
        deviceId: id,
        startDate: startDate ? new Date(startDate as string) : undefined,
        endDate: endDate ? new Date(endDate as string) : undefined,
        type: type as string,
        limit: limit ? parseInt(limit as string) : undefined,
        aggregation: aggregation as 'none' | 'hourly' | 'daily' | 'weekly' | undefined
      });
      
      res.status(200).json({
        success: true,
        data,
        message: '成功获取设备数据',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || '获取设备数据失败',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * 发送设备命令
   */
  public sendCommand = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const { command, parameters, priority } = req.body;
      
      // 发送命令
      const result = await this.deviceService.sendCommand({
        deviceId: id,
        command,
        parameters,
        priority
      });
      
      res.status(200).json({
        success: true,
        data: result,
        message: '成功发送设备命令',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || '发送设备命令失败',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * 获取设备监控数据
   */
  public getMonitoringData = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      
      // 获取监控数据
      const data = await this.deviceService.getMonitoringData(id);
      
      res.status(200).json({
        success: true,
        data,
        message: '成功获取设备监控数据',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || '获取设备监控数据失败',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };
}

#### 文件3: backend/src/controllers/template.controller.ts - 模板控制器
```typescript
import { Request, Response } from 'express';
import { TemplateService } from '../services/template.service';
import { validateSchema } from '../middleware/validation';
import { TemplateSchema, TemplateQuerySchema } from '../schemas/template.schema';

export class TemplateController {
  private templateService: TemplateService;

  constructor() {
    this.templateService = new TemplateService();
  }

  /**
   * 获取所有模板
   */
  public getAllTemplates = async (req: Request, res: Response): Promise<void> => {
    try {
      // 验证查询参数
      const validatedQuery = validateSchema(TemplateQuerySchema, req.query);
      
      // 获取模板
      const templates = await this.templateService.getAllTemplates(validatedQuery);
      
      res.status(200).json({
        success: true,
        data: templates,
        message: '成功获取模板列表',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || '获取模板列表失败',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * 获取模板详情
   */
  public getTemplateById = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      
      // 获取模板
      const template = await this.templateService.getTemplateById(id);
      
      res.status(200).json({
        success: true,
        data: template,
        message: '成功获取模板详情',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || '获取模板详情失败',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * 创建模板
   */
  public createTemplate = async (req: Request, res: Response): Promise<void> => {
    try {
      // 验证请求数据
      const validatedData = validateSchema(TemplateSchema, req.body);
      
      // 创建模板
      const template = await this.templateService.createTemplate({
        ...validatedData,
        authorId: req.user.id // 从认证中间件获取用户ID
      });
      
      res.status(201).json({
        success: true,
        data: template,
        message: '成功创建模板',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || '创建模板失败',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * 更新模板
   */
  public updateTemplate = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      
      // 验证请求数据
      const validatedData = validateSchema(TemplateSchema, req.body, { partial: true });
      
      // 更新模板
      const template = await this.templateService.updateTemplate(id, validatedData);
      
      res.status(200).json({
        success: true,
        data: template,
        message: '成功更新模板',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || '更新模板失败',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * 删除模板
   */
  public deleteTemplate = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      
      // 删除模板
      await this.templateService.deleteTemplate(id);
      
      res.status(200).json({
        success: true,
        message: '成功删除模板',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || '删除模板失败',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * 基于模板创建实验
   */
  public createExperimentFromTemplate = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const { title, description, customizations } = req.body;
      
      // 创建实验
      const experiment = await this.templateService.createExperimentFromTemplate(id, {
        userId: req.user.id,
        title,
        description,
        customizations
      });
      
      res.status(201).json({
        success: true,
        data: experiment,
        message: '成功基于模板创建实验',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || '基于模板创建实验失败',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };

  /**
   * 获取模板使用统计数据
   */
  public getTemplateStats = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      
      // 获取统计数据
      const stats = await this.templateService.getTemplateStats(id);
      
      res.status(200).json({
        success: true,
        data: stats,
        message: '成功获取模板统计数据',
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || '获取模板统计数据失败',
        error: error.name,
        timestamp: new Date().toISOString()
      });
    }
  };
}

export default new TemplateController();
```

以上代码展示了SSLAB-AI实验平台软件的核心部分，包括后端服务器配置、AI服务模块、前端应用框架、API服务层以及类型定义系统等关键组件。这些代码共同构成了一个完整的人工智能辅助实验平台，支持实验设计、数据分析、设备管理和智能交互等功能。平台采用TypeScript全栈开发，保证了类型安全和代码可维护性，并通过模块化架构实现了系统的可扩展性。
      h3: {
        fontSize: '1.75rem',
        fontWeight: 600,
      },
      h4: {
        fontSize: '1.5rem',
        fontWeight: 600,
      },
      h5: {
        fontSize: '1.25rem',
        fontWeight: 600,
      },
      h6: {
        fontSize: '1rem',
        fontWeight: 600,
      },
    },
    components: {
      MuiButton: {
        styleOverrides: {
          root: {
            textTransform: 'none',
            borderRadius: 8,
          },
        },
      },
      MuiPaper: {
        styleOverrides: {
          root: {
            borderRadius: 12,
          },
        },
      },
    },
  });
  // 检查用户认证状态
  useEffect(() => {
    const { isAuthenticated, fetchCurrentUser } = useUserStore.getState();
    const token = localStorage.getItem('token');

    if (token && !isAuthenticated) {
      // 验证token并获取用户信息
      fetchCurrentUser();
    }
  }, []);
  return (
    <ErrorBoundary FallbackComponent={ErrorFallback}>
      <HelmetProvider>
        <QueryClientProvider client={queryClient}>
          <ThemeProvider theme={theme}>
            <CssBaseline />
            <Toaster
                  position="top-right"
                  toastOptions={{
                    duration: 4000,
                    style: {
                      background: theme.palette.background.paper,
                      color: theme.palette.text.primary,
                      border: `1px solid ${theme.palette.divider}`,
                    },
                  }}
                />
                
                {/* PWA提示组件 */}
                <PWAPrompt autoShow={true} showNetworkStatus={true} />
                
                <Router future={{ v7_startTransition: true, v7_relativeSplatPath: true }}>
                  <Routes>
                    {/* 公开路由 */}
                    <Route path="/login" element={<Login />} />
                    <Route path="/register" element={<Register />} />
                    
                    {/* 受保护的路由 */}
                    <Route
                      path="/*"
                      element={
                        <ProtectedRoute>
                          <MainLayout>
                            {/* 在这里嵌套其他路由 */}
                            <Routes>
                              <Route path="dashboard" element={<Dashboard />} />
                              <Route path="experiments" element={<ExperimentList />} />
                              <Route path="experiments/create" element={<ExperimentCreate />} />
                              <Route path="experiments/:id" element={<ExperimentDetail />} />
                              <Route path="templates" element={<TemplateLibrary />} />
                              <Route path="templates/create" element={<TemplateCreate />} />
                              <Route path="templates/:id" element={<TemplateDetail />} />
                              <Route path="devices" element={<DeviceManagement />} />
                              <Route path="resources" element={<ResourceManagement />} />
                              <Route path="data-collection" element={<DataCollectionAnalysis />} />
                              <Route path="ai-assistant" element={<AIAssistant />} />
                              <Route path="guidance" element={<GuidanceSystem />} />
                              <Route path="api-check" element={<ApiIntegrationCheck />} />
                              <Route path="settings" element={<Settings />} />
                              <Route path="help" element={<Help />} />
                              <Route path="templates" element={<TemplateLibrary />} />
                              <Route path="templates/create" element={<TemplateCreate />} />
                              <Route path="templates/:id" element={<TemplateDetail />} />
                              {/* 默认重定向到dashboard */}
                              <Route index element={<Navigate to="/dashboard" />} />
                            </Routes>
                          </MainLayout>
                        </ProtectedRoute>
                      }
                    />
                  </Routes>
                </Router>
              </ThemeProvider>
        </QueryClientProvider>
      </HelmetProvider>
    </ErrorBoundary>
  );
};

export default App;
    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setLoading(true);
    
    try {
      const response = await apiService.sendAIMessage(input);
      
      const assistantMessage: AIMessage = {
        id: response.id,
        content: response.content,
        role: 'assistant',
        timestamp: new Date()
      };
      
      setMessages(prev => [...prev, assistantMessage]);
    } catch (error) {
      console.error('Failed to get AI response:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Paper sx={{ p: 2, height: '100%', display: 'flex', flexDirection: 'column' }}>
      <Typography variant="h6" gutterBottom>实验AI助手</Typography>
      
      <Box sx={{ flexGrow: 1, overflow: 'auto', mb: 2 }}>
        {messages.map(message => (
          <Box 
            key={message.id}
            sx={{
              p: 1,
              mb: 1,
              borderRadius: 1,
              bgcolor: message.role === 'user' ? 'primary.light' : 'background.paper',
              alignSelf: message.role === 'user' ? 'flex-end' : 'flex-start',
              maxWidth: '80%'
            }}
          >
            <Typography variant="body1">{message.content}</Typography>
          </Box>
        ))}
        {loading && (
          <Box sx={{ display: 'flex', justifyContent: 'center' }}>
            <CircularProgress size={24} />
          </Box>
        )}
      </Box>
      
      <Box sx={{ display: 'flex' }}>
        <TextField
          fullWidth
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="输入您的问题..."
          variant="outlined"
          size="small"
          onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
        />
        <Button 
          variant="contained" 
          color="primary" 
          onClick={handleSendMessage}
          disabled={loading || !input.trim()}
          sx={{ ml: 1 }}
        >
          发送
        </Button>
      </Box>
    </Paper>
  );
};

export default AIAssistant;
```

### 后端服务示例（Node.js/TypeScript）
```typescript
// AI助手服务示例
import { Request, Response } from 'express';
import { AIModelType, AICompletionOptions } from '../types';
import logger from '../utils/logger';
import { getModelConfig } from '../config/ai-models';

export class AIAssistantService {
  /**
   * 处理AI对话请求
   * @param modelType AI模型类型
   * @param message 用户消息
   * @param options 补全选项
   * @returns AI响应
   */
  async processAIMessage(modelType: AIModelType, message: string, options?: AICompletionOptions) {
    try {
      logger.info(`Processing AI message with model: ${modelType}`);
      
      // 获取模型配置
      const modelConfig = getModelConfig(modelType);
      if (!modelConfig) {
        throw new Error(`Model configuration not found for: ${modelType}`);
      }
      
      // 准备请求参数
      const requestParams = {
        model: modelConfig.modelId,
        messages: [{ role: 'user', content: message }],
        temperature: options?.temperature || modelConfig.defaultTemperature,
        max_tokens: options?.maxTokens || modelConfig.outputTokenLimit,
        // 其他参数...
      };
      
      // 调用AI模型API
      const response = await this.callModelAPI(modelType, requestParams);
      
      return {
        id: response.id,
        content: response.choices[0].message.content,
        model: modelType,
        usage: response.usage
      };
    } catch (error) {
      logger.error('Error processing AI message:', error);
      throw error;
    }
  }
  
  /**
   * 调用不同AI模型的API
   * @param modelType 模型类型
   * @param params 请求参数
   * @returns API响应
   */
  private async callModelAPI(modelType: AIModelType, params: any) {
    // 根据不同模型类型调用不同API
    switch (modelType) {
      case 'doubao':
        return this.callDoubaoAPI(params);
      case 'deepseek':
        return this.callDeepseekAPI(params);
      default:
        throw new Error(`Unsupported model type: ${modelType}`);
    }
  }
  
  // 具体模型API调用方法...
}

export default new AIAssistantService();
```

## 软件创新点与社会意义

### 创新点
1. 多模型智能调度技术，提高AI辅助实验的针对性和效率
2. 实验全生命周期管理，实现教学实验的数字化、智能化
3. 教育场景优化的人机交互，降低AI技术在教育中的应用门槛
4. 分布式实验资源管理，提高实验设备利用率
5. 教育数据的安全与隐私保护机制创新

### 社会意义
1. 促进教育公平：通过AI辅助，缩小不同地区、不同学校间的教育资源差距
2. 提升教育质量：个性化实验指导提高学习效果，培养创新能力
3. 优化教育资源：提高实验设备利用率，降低教育成本
4. 培养未来人才：训练学生使用AI工具的能力，适应智能化未来
5. 推动教育创新：探索AI与教育深度融合的新模式，引领教育变革

# 软著登记核心源代码

## 1. 前端应用主入口 (frontend/src/index.tsx)

```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from 'react-query';
import { ReactQueryDevtools } from 'react-query/devtools';
import { ThemeProvider, createTheme, CssBaseline } from '@mui/material';
import { Toaster } from 'react-hot-toast';
import App from './App';
import { FeatureFlagsProvider, EditionType } from './features/featureFlags';
import { LicensingProvider } from './features/licensing';
import './index.css';

// 创建React Query客户端
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 3,
      retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
      staleTime: 5 * 60 * 1000, // 5分钟
      cacheTime: 10 * 60 * 1000, // 10分钟
      refetchOnWindowFocus: false,
    },
    mutations: {
      retry: 1,
    },
  },
});

// 创建主题
const theme = createTheme({
  palette: {
    mode: 'light',
    primary: {
      main: '#1976d2',
      light: '#42a5f5',
      dark: '#1565c0',
    },
    secondary: {
      main: '#dc004e',
      light: '#ff5983',
      dark: '#9a0036',
    },
    background: {
      default: '#f5f5f5',
      paper: '#ffffff',
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h4: {
      fontWeight: 600,
    },
    h5: {
      fontWeight: 500,
    },
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          borderRadius: 8,
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          borderRadius: 0,
        },
      },
    },
  },
});

// 从环境变量获取版本，默认为basic
const editionFromEnv = (process.env.REACT_APP_EDITION as EditionType) || 'basic';

// 错误边界组件
class ErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean; error?: Error }
> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('React Error Boundary caught an error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div style={{ 
          padding: '20px', 
          textAlign: 'center',
          minHeight: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          flexDirection: 'column'
        }}>
          <h1>应用遇到错误</h1>
          <p>请刷新页面重试，如果问题持续存在，请联系技术支持。</p>
          <button 
            onClick={() => window.location.reload()}
            style={{
              padding: '10px 20px',
              backgroundColor: '#1976d2',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer'
            }}
          >
            刷新页面
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// 创建根元素
const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

// 渲染应用
root.render(
  <React.StrictMode>
    <ErrorBoundary>
      <QueryClientProvider client={queryClient}>
        <BrowserRouter>
          <ThemeProvider theme={theme}>
            <CssBaseline />
            <LicensingProvider>
              <FeatureFlagsProvider initialEdition={editionFromEnv}>
                <App />
                <Toaster
                  position="top-right"
                  toastOptions={{
                    duration: 4000,
                    style: {
                      background: '#363636',
                      color: '#fff',
                    },
                    success: {
                      duration: 3000,
                      iconTheme: {
                        primary: '#4caf50',
                        secondary: '#fff',
                      },
                    },
                    error: {
                      duration: 5000,
                      iconTheme: {
                        primary: '#f44336',
                        secondary: '#fff',
                      },
                    },
                  }}
                />
              </FeatureFlagsProvider>
            </LicensingProvider>
          </ThemeProvider>
        </BrowserRouter>
        {process.env.NODE_ENV === 'development' && <ReactQueryDevtools />}
      </QueryClientProvider>
    </ErrorBoundary>
  </React.StrictMode>
);

// PWA支持
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('SW registered: ', registration);
      })
      .catch((registrationError) => {
        console.log('SW registration failed: ', registrationError);
      });
  });
}

// 性能监控
const reportWebVitals = (metric: any) => {
  if (process.env.NODE_ENV === 'production') {
    // 这里可以发送到分析服务
    console.log(metric);
  }
};

// 启用性能监控
if (process.env.NODE_ENV === 'production') {
  import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
    getCLS(reportWebVitals);
    getFID(reportWebVitals);
    getFCP(reportWebVitals);
    getLCP(reportWebVitals);
    getTTFB(reportWebVitals);
  });
}

export default App;
```

## 2. 前端主应用组件 (frontend/src/App.tsx)

```tsx
import React, { useEffect, useState } from 'react';
import { Routes, Route, Navigate, useLocation } from 'react-router-dom';
import { Box, Container, CircularProgress, Alert, Snackbar } from '@mui/material';
import { useUserStore } from './store';
import { useFeatureFlags } from './features/featureFlags';
import { useLicensing } from './features/licensing';

// 布局组件
import Layout from './components/layout/Layout';
import PublicLayout from './components/layout/PublicLayout';

// 页面组件
import Dashboard from './pages/Dashboard';
import TeacherDashboard from './pages/TeacherDashboard';
import ExperimentList from './pages/experiments/ExperimentList';
import ExperimentCreate from './pages/experiments/ExperimentCreate';
import ExperimentDetail from './pages/experiments/ExperimentDetail';
import TemplateLibrary from './pages/templates/TemplateLibrary';
import TemplateDetail from './pages/templates/TemplateDetail';
import ResourceManagement from './pages/resources/ResourceManagement';
import GuidanceSystem from './pages/guidance/GuidanceSystem';
import Settings from './pages/Settings';
import AIModelSettings from './pages/settings/AIModelSettings';
import Login from './pages/Login';
import Register from './pages/Register';
import Help from './pages/Help';
import NotFound from './pages/NotFound';

// AI助手组件
import AIAssistant from './components/ai/AIAssistant';

// 权限守卫组件
interface ProtectedRouteProps {
  children: React.ReactNode;
  requireAuth?: boolean;
  requiredRole?: 'student' | 'teacher' | 'admin';
  requiredFeature?: string;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ 
  children, 
  requireAuth = true, 
  requiredRole,
  requiredFeature 
}) => {
  const { isAuthenticated, user } = useUserStore();
  const { isFeatureEnabled } = useFeatureFlags();
  const { isLicenseValid } = useLicensing();

  // 检查认证状态
  if (requireAuth && !isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  // 检查用户角色
  if (requiredRole && user?.role !== requiredRole) {
    return <Navigate to="/dashboard" replace />;
  }

  // 检查功能权限
  if (requiredFeature && !isFeatureEnabled(requiredFeature)) {
    return (
      <Alert severity="warning" sx={{ m: 2 }}>
        此功能在当前版本中不可用，请升级到更高版本。
      </Alert>
    );
  }

  // 检查许可证
  if (!isLicenseValid()) {
    return (
      <Alert severity="error" sx={{ m: 2 }}>
        许可证已过期，请联系管理员续费。
      </Alert>
    );
  }

  return <>{children}</>;
};

// 加载组件
const LoadingScreen: React.FC = () => (
  <Box
    display="flex"
    justifyContent="center"
    alignItems="center"
    minHeight="100vh"
    flexDirection="column"
  >
    <CircularProgress size={60} />
    <Box mt={2}>正在加载应用...</Box>
  </Box>
);

// 主应用组件
const App: React.FC = () => {
  const location = useLocation();
  const { 
    isAuthenticated, 
    user, 
    isLoading: userLoading, 
    fetchCurrentUser,
    error: userError 
  } = useUserStore();
  const { isFeatureEnabled } = useFeatureFlags();
  const [appLoading, setAppLoading] = useState(true);
  const [notification, setNotification] = useState<{
    open: boolean;
    message: string;
    severity: 'success' | 'error' | 'warning' | 'info';
  }>({ open: false, message: '', severity: 'info' });

  // 初始化应用
  useEffect(() => {
    const initializeApp = async () => {
      try {
        // 检查是否有存储的认证信息
        const token = localStorage.getItem('token');
        if (token) {
          await fetchCurrentUser();
        }
      } catch (error) {
        console.error('App initialization error:', error);
        setNotification({
          open: true,
          message: '应用初始化失败，请刷新页面重试',
          severity: 'error'
        });
      } finally {
        setAppLoading(false);
      }
    };

    initializeApp();
  }, [fetchCurrentUser]);

  // 路由变化时的处理
  useEffect(() => {
    // 页面访问统计
    if (process.env.NODE_ENV === 'production') {
      // 这里可以发送页面访问统计
      console.log('Page view:', location.pathname);
    }
  }, [location.pathname]);

  // 处理全局错误
  useEffect(() => {
    if (userError) {
      setNotification({
        open: true,
        message: userError,
        severity: 'error'
      });
    }
  }, [userError]);

  // 键盘快捷键处理
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Ctrl/Cmd + K 打开搜索
      if ((event.ctrlKey || event.metaKey) && event.key === 'k') {
        event.preventDefault();
        // 打开搜索功能
        console.log('Open search');
      }
      
      // Ctrl/Cmd + / 打开帮助
      if ((event.ctrlKey || event.metaKey) && event.key === '/') {
        event.preventDefault();
        // 打开帮助
        console.log('Open help');
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, []);

  // 显示加载状态
  if (appLoading || userLoading) {
    return <LoadingScreen />;
  }

  // 公共页面路由（不需要认证）
  const publicRoutes = ['/login', '/register', '/help'];
  const isPublicRoute = publicRoutes.includes(location.pathname);

  return (
    <>
      {/* 路由配置 */}
      <Routes>
        {/* 公共路由 */}
        <Route path="/login" element={
          <PublicLayout>
            <Login />
          </PublicLayout>
        } />
        <Route path="/register" element={
          <PublicLayout>
            <Register />
          </PublicLayout>
        } />
        <Route path="/help" element={
          <PublicLayout>
            <Help />
          </PublicLayout>
        } />

        {/* 受保护的路由 */}
        <Route path="/" element={
          <ProtectedRoute>
            <Layout>
              <Navigate to="/dashboard" replace />
            </Layout>
          </ProtectedRoute>
        } />
        
        <Route path="/dashboard" element={
          <ProtectedRoute>
            <Layout>
              {user?.role === 'teacher' ? <TeacherDashboard /> : <Dashboard />}
            </Layout>
          </ProtectedRoute>
        } />

        {/* 实验相关路由 */}
        <Route path="/experiments" element={
          <ProtectedRoute>
            <Layout>
              <ExperimentList />
            </Layout>
          </ProtectedRoute>
        } />
        <Route path="/experiments/create" element={
          <ProtectedRoute>
            <Layout>
              <ExperimentCreate />
            </Layout>
          </ProtectedRoute>
        } />
        <Route path="/experiments/:id" element={
          <ProtectedRoute>
            <Layout>
              <ExperimentDetail />
            </Layout>
          </ProtectedRoute>
        } />

        {/* 模板相关路由 */}
        <Route path="/templates" element={
          <ProtectedRoute requiredFeature="templates">
            <Layout>
              <TemplateLibrary />
            </Layout>
          </ProtectedRoute>
        } />
        <Route path="/templates/:id" element={
          <ProtectedRoute requiredFeature="templates">
            <Layout>
              <TemplateDetail />
            </Layout>
          </ProtectedRoute>
        } />

        {/* 资源管理路由 */}
        <Route path="/resources" element={
          <ProtectedRoute requiredRole="teacher">
            <Layout>
              <ResourceManagement />
            </Layout>
          </ProtectedRoute>
        } />

        {/* 指导系统路由 */}
        <Route path="/guidance" element={
          <ProtectedRoute requiredFeature="aiGuidance">
            <Layout>
              <GuidanceSystem />
            </Layout>
          </ProtectedRoute>
        } />

        {/* 设置相关路由 */}
        <Route path="/settings" element={
          <ProtectedRoute>
            <Layout>
              <Settings />
            </Layout>
          </ProtectedRoute>
        } />
        <Route path="/settings/ai-models" element={
          <ProtectedRoute requiredRole="admin">
            <Layout>
              <AIModelSettings />
            </Layout>
          </ProtectedRoute>
        } />

        {/* 404页面 */}
        <Route path="*" element={<NotFound />} />
      </Routes>

      {/* AI助手（仅在已认证且功能启用时显示） */}
      {isAuthenticated && !isPublicRoute && isFeatureEnabled('aiAssistant') && (
        <AIAssistant />
      )}

      {/* 全局通知 */}
      <Snackbar
        open={notification.open}
        autoHideDuration={6000}
        onClose={() => setNotification(prev => ({ ...prev, open: false }))}
        anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
      >
        <Alert 
          severity={notification.severity} 
          onClose={() => setNotification(prev => ({ ...prev, open: false }))}
        >
          {notification.message}
        </Alert>
      </Snackbar>
    </>
  );
};

export default App;
```

## 3. 前端API服务层 (frontend/src/services/api.ts)

```typescript
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { toast } from 'react-hot-toast';

// API响应类型定义
export interface ApiResponse<T = any> {
  data: T;
  message: string;
  success: boolean;
  code: number;
  timestamp: string;
}

// 分页响应类型
export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// API错误类型
export interface ApiError {
  message: string;
  code: number;
  details?: any;
}

// 请求拦截器配置
interface RequestInterceptorConfig {
  onRequest?: (config: AxiosRequestConfig) => AxiosRequestConfig;
  onRequestError?: (error: any) => Promise<any>;
}

// 响应拦截器配置
interface ResponseInterceptorConfig {
  onResponse?: (response: AxiosResponse) => AxiosResponse;
  onResponseError?: (error: any) => Promise<any>;
}

// API服务类
class ApiService {
  private client: AxiosInstance;
  private baseURL: string;
  private timeout: number = 30000;
  private retryAttempts: number = 3;
  private retryDelay: number = 1000;

  constructor() {
    // 根据环境确定API基础URL
    this.baseURL = this.getBaseURL();
    
    // 创建Axios实例
    this.client = axios.create({
      baseURL: this.baseURL,
      timeout: this.timeout,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    });

    // 设置拦截器
    this.setupInterceptors();
  }

  /**
   * 获取API基础URL
   */
  private getBaseURL(): string {
    if (process.env.NODE_ENV === 'development') {
      return process.env.REACT_APP_API_URL || 'http://localhost:3001/api';
    }
    
    if (process.env.NODE_ENV === 'production') {
      return process.env.REACT_APP_API_URL || '/api';
    }
    
    return '/api';
  }

  /**
   * 设置请求和响应拦截器
   */
  private setupInterceptors(): void {
    // 请求拦截器
    this.client.interceptors.request.use(
      (config) => {
        // 添加认证token
        const token = localStorage.getItem('token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }

        // 添加请求ID用于追踪
        config.headers['X-Request-ID'] = this.generateRequestId();

        // 添加时间戳
        config.headers['X-Timestamp'] = Date.now().toString();

        // 记录请求日志
        if (process.env.NODE_ENV === 'development') {
          console.log('🚀 API Request:', {
            method: config.method?.toUpperCase(),
            url: config.url,
            data: config.data,
            params: config.params,
          });
        }

        return config;
      },
      (error) => {
        console.error('❌ Request Error:', error);
        return Promise.reject(error);
      }
    );

    // 响应拦截器
    this.client.interceptors.response.use(
      (response) => {
        // 记录响应日志
        if (process.env.NODE_ENV === 'development') {
          console.log('✅ API Response:', {
            status: response.status,
            url: response.config.url,
            data: response.data,
          });
        }

        return response;
      },
      async (error) => {
        const originalRequest = error.config;

        // 记录错误日志
        console.error('❌ API Error:', {
          status: error.response?.status,
          url: error.config?.url,
          message: error.response?.data?.message || error.message,
        });

        // 处理401未授权错误
        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true;
          
          // 清除本地存储的token
          localStorage.removeItem('token');
          
          // 重定向到登录页面
          if (window.location.pathname !== '/login') {
            window.location.href = '/login';
          }
          
          return Promise.reject(error);
        }

        // 处理403权限错误
        if (error.response?.status === 403) {
          toast.error('您没有执行此操作的权限');
          return Promise.reject(error);
        }

        // 处理404错误
        if (error.response?.status === 404) {
          toast.error('请求的资源不存在');
          return Promise.reject(error);
        }

        // 处理500服务器错误
        if (error.response?.status >= 500) {
          toast.error('服务器内部错误，请稍后重试');
          return Promise.reject(error);
        }

        // 处理网络错误
        if (!error.response) {
          toast.error('网络连接错误，请检查网络设置');
          return Promise.reject(error);
        }

        // 处理超时错误
        if (error.code === 'ECONNABORTED') {
          toast.error('请求超时，请重试');
          return Promise.reject(error);
        }

        // 自动重试机制
        if (originalRequest._retryCount < this.retryAttempts) {
          originalRequest._retryCount = originalRequest._retryCount || 0;
          originalRequest._retryCount++;

          await this.delay(this.retryDelay * originalRequest._retryCount);
          return this.client(originalRequest);
        }

        return Promise.reject(error);
      }
    );
  }

  /**
   * 生成请求ID
   */
  private generateRequestId(): string {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * 延迟函数
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * GET请求
   */
  async get<T = any>(url: string, params?: any, config?: AxiosRequestConfig): Promise<T> {
    try {
      const response = await this.client.get<ApiResponse<T>>(url, { 
        params, 
        ...config 
      });
      return response.data.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  /**
   * POST请求
   */
  async post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    try {
      const response = await this.client.post<ApiResponse<T>>(url, data, config);
      return response.data.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  /**
   * PUT请求
   */
  async put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    try {
      const response = await this.client.put<ApiResponse<T>>(url, data, config);
      return response.data.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  /**
   * DELETE请求
   */
  async delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {
    try {
      const response = await this.client.delete<ApiResponse<T>>(url, config);
      return response.data.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  /**
   * PATCH请求
   */
  async patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    try {
      const response = await this.client.patch<ApiResponse<T>>(url, data, config);
      return response.data.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  /**
   * 文件上传
   */
  async upload<T = any>(url: string, file: File, onProgress?: (progress: number) => void): Promise<T> {
    const formData = new FormData();
    formData.append('file', file);

    try {
      const response = await this.client.post<ApiResponse<T>>(url, formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
        onUploadProgress: (progressEvent) => {
          if (onProgress && progressEvent.total) {
            const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);
            onProgress(progress);
          }
        },
      });
      return response.data.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  /**
   * 下载文件
   */
  async download(url: string, filename?: string): Promise<void> {
    try {
      const response = await this.client.get(url, {
        responseType: 'blob',
      });

      // 创建下载链接
      const downloadUrl = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = downloadUrl;
      link.download = filename || 'download';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(downloadUrl);
    } catch (error) {
      throw this.handleError(error);
    }
  }

  /**
   * 错误处理
   */
  private handleError(error: any): ApiError {
    if (error.response) {
      // 服务器响应错误
      return {
        message: error.response.data?.message || '服务器错误',
        code: error.response.status,
        details: error.response.data,
      };
    } else if (error.request) {
      // 网络错误
      return {
        message: '网络连接失败',
        code: 0,
        details: error.request,
      };
    } else {
      // 其他错误
      return {
        message: error.message || '未知错误',
        code: -1,
        details: error,
      };
    }
  }

  /**
   * 取消请求
   */
  createCancelToken() {
    return axios.CancelToken.source();
  }

  /**
   * 检查是否为取消请求
   */
  isCancel(error: any): boolean {
    return axios.isCancel(error);
  }

  // === 业务API方法 ===

  /**
   * 用户认证相关API
   */
  async login(email: string, password: string) {
    return this.post('/auth/login', { email, password });
  }

  async register(userData: any) {
    return this.post('/auth/register', userData);
  }

  async logout() {
    return this.post('/auth/logout');
  }

  async getCurrentUser() {
    return this.get('/auth/me');
  }

  async refreshToken() {
    return this.post('/auth/refresh');
  }

  /**
   * 实验相关API
   */
  async getExperiments(params?: any) {
    return this.get('/experiments', params);
  }

  async getExperiment(id: string) {
    return this.get(`/experiments/${id}`);
  }

  async createExperiment(data: any) {
    return this.post('/experiments', data);
  }

  async updateExperiment(id: string, data: any) {
    return this.put(`/experiments/${id}`, data);
  }

  async deleteExperiment(id: string) {
    return this.delete(`/experiments/${id}`);
  }

  async startExperiment(id: string) {
    return this.post(`/experiments/${id}/start`);
  }

  async stopExperiment(id: string) {
    return this.post(`/experiments/${id}/stop`);
  }

  /**
   * AI助手相关API
   */
  async sendAIMessage(message: string, sessionId?: string) {
    return this.post('/ai/chat', { message, sessionId });
  }

  async getAIChatHistory(sessionId: string) {
    return this.get(`/ai/chat/${sessionId}/history`);
  }

  async createAISession() {
    return this.post('/ai/chat/session');
  }

  /**
   * 模板相关API
   */
  async getTemplates(params?: any) {
    return this.get('/templates', params);
  }

  async getTemplate(id: string) {
    return this.get(`/templates/${id}`);
  }

  /**
   * 指导建议相关API
   */
  async getGuidanceSuggestions(params?: any) {
    return this.get('/guidance/suggestions', params);
  }

  async createGuidanceSuggestion(data: any) {
    return this.post('/guidance/suggestions', data);
  }

  async getGuidanceSessionHistory(sessionId: string) {
    return this.get(`/guidance/sessions/${sessionId}`);
  }
}

// 创建并导出API服务实例
const apiService = new ApiService();
export default apiService;
```

## 4. 后端主服务器 (backend/src/server.ts)

```typescript
import express, { Express, Request, Response, NextFunction } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import rateLimit from 'express-rate-limit';
import morgan from 'morgan';
import path from 'path';
import fs from 'fs';
import { createServer } from 'http';
import { Server as SocketIOServer } from 'socket.io';
import swaggerUi from 'swagger-ui-express';
import swaggerJsdoc from 'swagger-jsdoc';

// 路由导入
import authRoutes from './routes/auth.routes';
import experimentRoutes from './routes/experiment.routes';
import templateRoutes from './routes/template.routes';
import guidanceRoutes from './routes/guidance.routes';
import deviceRoutes from './routes/device.routes';
import aiRoutes from './routes/ai.routes';
import userRoutes from './routes/user.routes';
import uploadRoutes from './routes/upload.routes';

// 中间件导入
import { errorHandler } from './middleware/errorHandler';
import { requestLogger } from './middleware/requestLogger';
import { authMiddleware } from './middleware/auth';
import { validateRequest } from './middleware/validation';

// 工具导入
import logger from './utils/logger';
import { connectDatabase } from './utils/database';
import { initializeRedis } from './utils/redis';
import { setupWebSocket } from './utils/websocket';

// 类型定义
interface ServerConfig {
  port: number;
  host: string;
  environment: string;
  corsOrigins: string[];
  rateLimitWindowMs: number;
  rateLimitMax: number;
  jwtSecret: string;
  databaseUrl: string;
  redisUrl: string;
}

// 环境变量配置
const config: ServerConfig = {
  port: parseInt(process.env.PORT || '3001', 10),
  host: process.env.HOST || '0.0.0.0',
  environment: process.env.NODE_ENV || 'development',
  corsOrigins: process.env.CORS_ORIGINS?.split(',') || ['http://localhost:3000'],
  rateLimitWindowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS || '900000', 10), // 15分钟
  rateLimitMax: parseInt(process.env.RATE_LIMIT_MAX || '100', 10), // 每个IP 100次请求
  jwtSecret: process.env.JWT_SECRET || 'your-secret-key',
  databaseUrl: process.env.DATABASE_URL || 'mongodb://localhost:27017/aicam',
  redisUrl: process.env.REDIS_URL || 'redis://localhost:6379',
};

// Swagger配置
const swaggerOptions = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'SSLAB-AI实验平台 API',
      version: '1.0.0',
      description: '人工智能辅助实验平台后端API文档',
      contact: {
        name: 'API支持',
        email: 'support@sslab.ai',
      },
    },
    servers: [
      {
        url: `http://localhost:${config.port}/api`,
        description: '开发环境',
      },
      {
        url: 'https://api.sslab.ai',
        description: '生产环境',
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
        },
      },
    },
    security: [
      {
        bearerAuth: [],
      },
    ],
  },
  apis: ['./src/routes/*.ts', './src/models/*.ts'],
};

class APIServer {
  private app: Express;
  private server: any;
  private io: SocketIOServer | null = null;
  private isShuttingDown = false;

  constructor() {
    this.app = express();
    this.setupMiddleware();
    this.setupRoutes();
    this.setupErrorHandling();
  }

  /**
   * 设置中间件
   */
  private setupMiddleware(): void {
    // 安全头设置
    this.app.use(helmet({
      crossOriginEmbedderPolicy: false,
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'", "https:"],
          scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
          imgSrc: ["'self'", "data:", "https:"],
          connectSrc: ["'self'", "ws:", "wss:"],
          fontSrc: ["'self'", "https:", "data:"],
          objectSrc: ["'none'"],
          mediaSrc: ["'self'"],
          frameSrc: ["'none'"],
        },
      },
    }));

    // CORS配置
    this.app.use(cors({
      origin: (origin, callback) => {
        // 开发环境允许所有来源
        if (config.environment === 'development') {
          callback(null, true);
          return;
        }

        // 生产环境检查允许的来源
        if (!origin || config.corsOrigins.includes(origin)) {
          callback(null, true);
        } else {
          callback(new Error('CORS policy violation'));
        }
      },
      credentials: true,
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
      allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID', 'X-Timestamp'],
    }));

    // 压缩响应
    this.app.use(compression());

    // 请求体解析
    this.app.use(express.json({ limit: '50mb' }));
    this.app.use(express.urlencoded({ extended: true, limit: '50mb' }));

    // 请求日志
    this.app.use(morgan('combined', {
      stream: {
        write: (message: string) => {
          logger.info(message.trim());
        },
      },
    }));

    // 自定义请求日志中间件
    this.app.use(requestLogger);

    // 速率限制
    const limiter = rateLimit({
      windowMs: config.rateLimitWindowMs,
      max: config.rateLimitMax,
      message: {
        error: '请求过于频繁，请稍后再试',
        code: 429,
      },
      standardHeaders: true,
      legacyHeaders: false,
      handler: (req: Request, res: Response) => {
        logger.warn(`Rate limit exceeded for IP: ${req.ip}`);
        res.status(429).json({
          error: '请求过于频繁，请稍后再试',
          code: 429,
          timestamp: new Date().toISOString(),
        });
      },
    });
    this.app.use('/api', limiter);

    // 静态文件服务
    if (config.environment === 'production') {
      this.app.use(express.static(path.join(__dirname, '../../../frontend/build')));
    }

    // 健康检查中间件
    this.app.use('/health', (req: Request, res: Response) => {
      res.status(200).json({
        status: 'healthy',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        version: process.env.npm_package_version || '1.0.0',
      });
    });
  }

  /**
   * 设置路由
   */
  private setupRoutes(): void {
    // API版本前缀
    const apiPrefix = '/api/v1';

    // Swagger文档
    const swaggerSpecs = swaggerJsdoc(swaggerOptions);
    this.app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpecs));

    // 认证路由
    this.app.use(`${apiPrefix}/auth`, authRoutes);

    // 受保护的路由（需要认证）
    this.app.use(`${apiPrefix}/experiments`, authMiddleware, experimentRoutes);
    this.app.use(`${apiPrefix}/templates`, authMiddleware, templateRoutes);
    this.app.use(`${apiPrefix}/guidance`, authMiddleware, guidanceRoutes);
    this.app.use(`${apiPrefix}/devices`, authMiddleware, deviceRoutes);
    this.app.use(`${apiPrefix}/ai`, authMiddleware, aiRoutes);
    this.app.use(`${apiPrefix}/users`, authMiddleware, userRoutes);
    this.app.use(`${apiPrefix}/upload`, authMiddleware, uploadRoutes);

    // 根路径处理
    this.app.get('/', (req: Request, res: Response) => {
      res.json({
        message: 'SSLAB-AI实验平台后端服务',
        version: process.env.npm_package_version || '1.0.0',
        environment: config.environment,
        timestamp: new Date().toISOString(),
        docs: '/api-docs',
        health: '/health',
      });
    });

    // 前端路由支持（生产环境）
    if (config.environment === 'production') {
      this.app.get('*', (req: Request, res: Response) => {
        res.sendFile(path.join(__dirname, '../../../frontend/build/index.html'));
      });
    }

    // 404处理
    this.app.use('*', (req: Request, res: Response) => {
      logger.warn(`404 - Route not found: ${req.method} ${req.originalUrl}`);
      res.status(404).json({
        error: '请求的资源不存在',
        code: 404,
        path: req.originalUrl,
        timestamp: new Date().toISOString(),
      });
    });
  }

  /**
   * 设置错误处理
   */
  private setupErrorHandling(): void {
    // 全局错误处理中间件
    this.app.use(errorHandler);

    // 未捕获异常处理
    process.on('uncaughtException', (error: Error) => {
      logger.error('Uncaught Exception:', error);
      this.gracefulShutdown('SIGTERM');
    });

    // 未处理的Promise拒绝
    process.on('unhandledRejection', (reason: any, promise: Promise<any>) => {
      logger.error('Unhandled Rejection at:', promise, 'reason:', reason);
      this.gracefulShutdown('SIGTERM');
    });

    // 进程信号处理
    process.on('SIGTERM', () => this.gracefulShutdown('SIGTERM'));
    process.on('SIGINT', () => this.gracefulShutdown('SIGINT'));
  }

  /**
   * 启动服务器
   */
  async start(): Promise<void> {
    try {
      // 初始化数据库
      await connectDatabase(config.databaseUrl);
      logger.info('Database connected successfully');

      // 初始化Redis
      await initializeRedis(config.redisUrl);
      logger.info('Redis connected successfully');

      // 创建HTTP服务器
      this.server = createServer(this.app);

      // 设置WebSocket
      this.io = setupWebSocket(this.server);
      logger.info('WebSocket server initialized');

      // 启动服务器
      this.server.listen(config.port, config.host, () => {
        logger.info(`🚀 Server is running on http://${config.host}:${config.port}`);
        logger.info(`📚 API Documentation: http://${config.host}:${config.port}/api-docs`);
        logger.info(`🔍 Health Check: http://${config.host}:${config.port}/health`);
        logger.info(`🌍 Environment: ${config.environment}`);
      });

      // 服务器错误处理
      this.server.on('error', (error: any) => {
        if (error.syscall !== 'listen') {
          throw error;
        }

        const bind = typeof config.port === 'string'
          ? 'Pipe ' + config.port
          : 'Port ' + config.port;

        switch (error.code) {
          case 'EACCES':
            logger.error(`${bind} requires elevated privileges`);
            process.exit(1);
            break;
          case 'EADDRINUSE':
            logger.error(`${bind} is already in use`);
            process.exit(1);
            break;
          default:
            throw error;
        }
      });

    } catch (error) {
      logger.error('Failed to start server:', error);
      process.exit(1);
    }
  }

  /**
   * 优雅关闭服务器
   */
  private async gracefulShutdown(signal: string): Promise<void> {
    if (this.isShuttingDown) {
      return;
    }

    this.isShuttingDown = true;
    logger.info(`🛑 Received ${signal}. Starting graceful shutdown...`);

    try {
      // 停止接受新连接
      if (this.server) {
        this.server.close(() => {
          logger.info('HTTP server closed');
        });
      }

      // 关闭WebSocket连接
      if (this.io) {
        this.io.close(() => {
          logger.info('WebSocket server closed');
        });
      }

      // 等待现有连接完成
      await new Promise((resolve) => {
        setTimeout(resolve, 5000); // 5秒超时
      });

      logger.info('✅ Graceful shutdown completed');
      process.exit(0);
    } catch (error) {
      logger.error('❌ Error during graceful shutdown:', error);
      process.exit(1);
    }
  }

  /**
   * 获取服务器实例
   */
  getApp(): Express {
    return this.app;
  }

  /**
   * 获取WebSocket实例
   */
  getIO(): SocketIOServer | null {
    return this.io;
  }
}

// 创建并启动服务器
const server = new APIServer();

// 仅在直接运行时启动服务器
if (require.main === module) {
  server.start().catch((error) => {
    logger.error('Failed to start application:', error);
    process.exit(1);
  });
}

export default server;
export { APIServer };
```

## 5. 后端AI服务模块 (backend/src/services/ai.service.ts)

```typescript
import axios, { AxiosInstance, AxiosResponse } from 'axios';
import { EventEmitter } from 'events';
import WebSocket from 'ws';
import { Redis } from 'ioredis';
import logger from '../utils/logger';
import { getRedisClient } from '../utils/redis';

// AI模型类型定义
export enum AIModelType {
  DOUBAO = 'doubao',
  DEEPSEEK = 'deepseek',
  CLAUDE = 'claude',
  GPT4 = 'gpt4',
  CUSTOM = 'custom'
}

// AI消息类型
export interface AIMessage {
  id?: string;
  role: 'system' | 'user' | 'assistant';
  content: string;
  timestamp?: Date;
  metadata?: Record<string, any>;
}

// AI会话类型
export interface AISession {
  id: string;
  userId: string;
  modelType: AIModelType;
  messages: AIMessage[];
  createdAt: Date;
  updatedAt: Date;
  metadata?: Record<string, any>;
}

// AI完成选项
export interface AICompletionOptions {
  temperature?: number;
  maxTokens?: number;
  topP?: number;
  frequencyPenalty?: number;
  presencePenalty?: number;
  stream?: boolean;
  systemPrompt?: string;
  experimentContext?: any;
}

// AI模型配置
export interface AIModelConfig {
  modelId: string;
  apiKey: string;
  baseURL: string;
  defaultTemperature: number;
  maxTokens: number;
  outputTokenLimit: number;
  rateLimitRPM: number;
  rateLimitTPM: number;
  supportStreaming: boolean;
  features: string[];
}

// AI响应类型
export interface AIResponse {
  id: string;
  content: string;
  model: AIModelType;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  finishReason?: string;
  metadata?: Record<string, any>;
}

// 错误类型
export class AIServiceError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 500,
    public details?: any
  ) {
    super(message);
    this.name = 'AIServiceError';
  }
}

/**
 * AI服务类 - 管理多个AI模型的调用和会话
 */
export class AIService extends EventEmitter {
  private models: Map<AIModelType, AIModelConfig> = new Map();
  private httpClients: Map<AIModelType, AxiosInstance> = new Map();
  private wsConnections: Map<string, WebSocket> = new Map();
  private redis: Redis;
  private sessionCache: Map<string, AISession> = new Map();
  private rateLimiters: Map<string, { count: number; resetTime: number }> = new Map();

  constructor() {
    super();
    this.redis = getRedisClient();
    this.initializeModels();
    this.setupEventHandlers();
  }

  /**
   * 初始化AI模型配置
   */
  private initializeModels(): void {
    // 豆包模型配置
    this.models.set(AIModelType.DOUBAO, {
      modelId: 'ep-20241024235508-fqn7t',
      apiKey: process.env.DOUBAO_API_KEY || '',
      baseURL: 'https://ark.cn-beijing.volces.com/api/v3',
      defaultTemperature: 0.7,
      maxTokens: 4000,
      outputTokenLimit: 4000,
      rateLimitRPM: 300,
      rateLimitTPM: 100000,
      supportStreaming: true,
      features: ['chat', 'reasoning', 'multimodal']
    });

    // DeepSeek模型配置
    this.models.set(AIModelType.DEEPSEEK, {
      modelId: 'deepseek-reasoner',
      apiKey: process.env.DEEPSEEK_API_KEY || '',
      baseURL: 'https://api.deepseek.com/v1',
      defaultTemperature: 0.8,
      maxTokens: 8000,
      outputTokenLimit: 8000,
      rateLimitRPM: 200,
      rateLimitTPM: 50000,
      supportStreaming: true,
      features: ['chat', 'reasoning', 'code', 'analysis']
    });

    // 初始化HTTP客户端
    this.models.forEach((config, modelType) => {
      const client = axios.create({
        baseURL: config.baseURL,
        timeout: 60000,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${config.apiKey}`,
        },
      });

      // 请求拦截器
      client.interceptors.request.use((requestConfig) => {
        logger.debug(`AI API Request: ${modelType}`, {
          url: requestConfig.url,
          method: requestConfig.method,
        });
        return requestConfig;
      });

      // 响应拦截器
      client.interceptors.response.use(
        (response) => {
          logger.debug(`AI API Response: ${modelType}`, {
            status: response.status,
            usage: response.data?.usage,
          });
          return response;
        },
        (error) => {
          logger.error(`AI API Error: ${modelType}`, {
            status: error.response?.status,
            message: error.response?.data?.message || error.message,
          });
          throw new AIServiceError(
            error.response?.data?.message || 'AI API调用失败',
            'API_ERROR',
            error.response?.status || 500,
            error.response?.data
          );
        }
      );

      this.httpClients.set(modelType, client);
    });
  }

  /**
   * 设置事件处理器
   */
  private setupEventHandlers(): void {
    this.on('messageGenerated', (sessionId: string, message: AIMessage) => {
      logger.info(`AI message generated for session: ${sessionId}`);
      this.cacheMessage(sessionId, message);
    });

    this.on('sessionCreated', (session: AISession) => {
      logger.info(`AI session created: ${session.id}`);
      this.cacheSession(session);
    });

    this.on('error', (error: Error) => {
      logger.error('AI Service Error:', error);
    });
  }

  /**
   * 创建AI会话
   */
  async createSession(
    userId: string,
    modelType: AIModelType = AIModelType.DOUBAO,
    metadata?: Record<string, any>
  ): Promise<AISession> {
    const session: AISession = {
      id: this.generateSessionId(),
      userId,
      modelType,
      messages: [],
      createdAt: new Date(),
      updatedAt: new Date(),
      metadata
    };

    // 缓存会话
    await this.cacheSession(session);
    
    this.emit('sessionCreated', session);
    return session;
  }

  /**
   * 发送消息到AI模型
   */
  async sendMessage(
    sessionId: string,
    message: string,
    options?: AICompletionOptions
  ): Promise<AIResponse> {
    try {
      // 获取会话
      const session = await this.getSession(sessionId);
      if (!session) {
        throw new AIServiceError('会话不存在', 'SESSION_NOT_FOUND', 404);
      }

      // 检查速率限制
      await this.checkRateLimit(session.modelType, session.userId);

      // 准备消息
      const userMessage: AIMessage = {
        id: this.generateMessageId(),
        role: 'user',
        content: message,
        timestamp: new Date()
      };

      // 添加到会话
      session.messages.push(userMessage);

      // 调用AI模型
      const response = await this.callAIModel(session, options);

      // 创建助手消息
      const assistantMessage: AIMessage = {
        id: response.id,
        role: 'assistant',
        content: response.content,
        timestamp: new Date(),
        metadata: {
          model: response.model,
          usage: response.usage,
          finishReason: response.finishReason
        }
      };

      // 添加到会话
      session.messages.push(assistantMessage);
      session.updatedAt = new Date();

      // 更新缓存
      await this.cacheSession(session);

      this.emit('messageGenerated', sessionId, assistantMessage);
      return response;

    } catch (error) {
      logger.error('Error sending AI message:', error);
      if (error instanceof AIServiceError) {
        throw error;
      }
      throw new AIServiceError('发送消息失败', 'SEND_MESSAGE_ERROR', 500, error);
    }
  }

  /**
   * 流式发送消息
   */
  async sendMessageStream(
    sessionId: string,
    message: string,
    onChunk: (chunk: string) => void,
    options?: AICompletionOptions
  ): Promise<AIResponse> {
    try {
      const session = await this.getSession(sessionId);
      if (!session) {
        throw new AIServiceError('会话不存在', 'SESSION_NOT_FOUND', 404);
      }

      // 检查模型是否支持流式输出
      const modelConfig = this.models.get(session.modelType);
      if (!modelConfig?.supportStreaming) {
        throw new AIServiceError('该模型不支持流式输出', 'STREAMING_NOT_SUPPORTED', 400);
      }

      return await this.callAIModelStream(session, message, onChunk, options);

    } catch (error) {
      logger.error('Error sending AI message stream:', error);
      throw error;
    }
  }

  /**
   * 调用AI模型
   */
  private async callAIModel(
    session: AISession,
    options?: AICompletionOptions
  ): Promise<AIResponse> {
    const modelConfig = this.models.get(session.modelType);
    const client = this.httpClients.get(session.modelType);

    if (!modelConfig || !client) {
      throw new AIServiceError('模型配置不存在', 'MODEL_NOT_CONFIGURED', 500);
    }

    // 准备请求参数
    const requestData = this.prepareRequestData(session, modelConfig, options);

    try {
      const response: AxiosResponse = await client.post('/chat/completions', requestData);
      return this.parseAIResponse(response.data, session.modelType);
    } catch (error) {
      throw this.handleAPIError(error, session.modelType);
    }
  }

  /**
   * 流式调用AI模型
   */
  private async callAIModelStream(
    session: AISession,
    message: string,
    onChunk: (chunk: string) => void,
    options?: AICompletionOptions
  ): Promise<AIResponse> {
    const modelConfig = this.models.get(session.modelType);
    if (!modelConfig) {
      throw new AIServiceError('模型配置不存在', 'MODEL_NOT_CONFIGURED', 500);
    }

    // 实现流式调用逻辑
    return new Promise((resolve, reject) => {
      // 这里实现WebSocket或SSE流式调用
      // 简化实现，实际应使用WebSocket或Server-Sent Events
      setTimeout(() => {
        const mockResponse: AIResponse = {
          id: this.generateMessageId(),
          content: `这是对"${message}"的AI回复（流式模式）`,
          model: session.modelType,
          usage: {
            promptTokens: 50,
            completionTokens: 100,
            totalTokens: 150
          }
        };
        resolve(mockResponse);
      }, 1000);
    });
  }

  /**
   * 准备请求数据
   */
  private prepareRequestData(
    session: AISession,
    modelConfig: AIModelConfig,
    options?: AICompletionOptions
  ): any {
    const messages = session.messages.map(msg => ({
      role: msg.role,
      content: msg.content
    }));

    // 添加系统提示
    if (options?.systemPrompt) {
      messages.unshift({
        role: 'system',
        content: options.systemPrompt
      });
    }

    return {
      model: modelConfig.modelId,
      messages,
      temperature: options?.temperature ?? modelConfig.defaultTemperature,
      max_tokens: Math.min(
        options?.maxTokens ?? modelConfig.maxTokens,
        modelConfig.outputTokenLimit
      ),
      top_p: options?.topP ?? 1.0,
      frequency_penalty: options?.frequencyPenalty ?? 0,
      presence_penalty: options?.presencePenalty ?? 0,
      stream: options?.stream ?? false,
      user: session.userId
    };
  }

  /**
   * 解析AI响应
   */
  private parseAIResponse(data: any, modelType: AIModelType): AIResponse {
    const choice = data.choices?.[0];
    if (!choice) {
      throw new AIServiceError('无效的AI响应', 'INVALID_RESPONSE', 500);
    }

    return {
      id: data.id || this.generateMessageId(),
      content: choice.message?.content || '',
      model: modelType,
      usage: data.usage,
      finishReason: choice.finish_reason,
      metadata: {
        created: data.created,
        object: data.object
      }
    };
  }

  /**
   * 处理API错误
   */
  private handleAPIError(error: any, modelType: AIModelType): AIServiceError {
    if (error.response) {
      const status = error.response.status;
      const message = error.response.data?.message || error.message;

      switch (status) {
        case 401:
          return new AIServiceError(`${modelType}模型认证失败`, 'AUTH_ERROR', 401);
        case 429:
          return new AIServiceError(`${modelType}模型请求频率超限`, 'RATE_LIMIT', 429);
        case 500:
          return new AIServiceError(`${modelType}模型服务器错误`, 'SERVER_ERROR', 500);
        default:
          return new AIServiceError(message, 'API_ERROR', status);
      }
    }

    return new AIServiceError('网络连接失败', 'NETWORK_ERROR', 503);
  }

  /**
   * 获取会话
   */
  private async getSession(sessionId: string): Promise<AISession | null> {
    // 先从缓存查找
    if (this.sessionCache.has(sessionId)) {
      return this.sessionCache.get(sessionId)!;
    }

    // 从Redis查找
    try {
      const cached = await this.redis.get(`ai_session:${sessionId}`);
      if (cached) {
        const session: AISession = JSON.parse(cached);
        this.sessionCache.set(sessionId, session);
        return session;
      }
    } catch (error) {
      logger.error('Error getting session from Redis:', error);
    }

    return null;
  }

  /**
   * 缓存会话
   */
  private async cacheSession(session: AISession): Promise<void> {
    // 内存缓存
    this.sessionCache.set(session.id, session);

    // Redis缓存
    try {
      await this.redis.setex(
        `ai_session:${session.id}`,
        3600, // 1小时过期
        JSON.stringify(session)
      );
    } catch (error) {
      logger.error('Error caching session to Redis:', error);
    }
  }

  /**
   * 缓存消息
   */
  private async cacheMessage(sessionId: string, message: AIMessage): Promise<void> {
    try {
      await this.redis.lpush(
        `ai_messages:${sessionId}`,
        JSON.stringify(message)
      );
      await this.redis.expire(`ai_messages:${sessionId}`, 86400); // 24小时过期
    } catch (error) {
      logger.error('Error caching message to Redis:', error);
    }
  }

  /**
   * 检查速率限制
   */
  private async checkRateLimit(modelType: AIModelType, userId: string): Promise<void> {
    const modelConfig = this.models.get(modelType);
    if (!modelConfig) return;

    const key = `${modelType}:${userId}`;
    const now = Date.now();
    const windowMs = 60000; // 1分钟窗口

    let limiter = this.rateLimiters.get(key);
    if (!limiter || now > limiter.resetTime) {
      limiter = { count: 0, resetTime: now + windowMs };
      this.rateLimiters.set(key, limiter);
    }

    if (limiter.count >= modelConfig.rateLimitRPM) {
      throw new AIServiceError(
        '请求频率超限，请稍后再试',
        'RATE_LIMIT_EXCEEDED',
        429
      );
    }

    limiter.count++;
  }

  /**
   * 生成会话ID
   */
  private generateSessionId(): string {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * 生成消息ID
   */
  private generateMessageId(): string {
    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * 获取模型列表
   */
  getAvailableModels(): AIModelType[] {
    return Array.from(this.models.keys());
  }

  /**
   * 获取模型配置
   */
  getModelConfig(modelType: AIModelType): AIModelConfig | undefined {
    return this.models.get(modelType);
  }

  /**
   * 删除会话
   */
  async deleteSession(sessionId: string): Promise<boolean> {
    try {
      // 从缓存删除
      this.sessionCache.delete(sessionId);

      // 从Redis删除
      await this.redis.del(`ai_session:${sessionId}`);
      await this.redis.del(`ai_messages:${sessionId}`);

      return true;
    } catch (error) {
      logger.error('Error deleting session:', error);
      return false;
    }
  }

  /**
   * 清理过期会话
   */
  async cleanupExpiredSessions(): Promise<void> {
    try {
      const pattern = 'ai_session:*';
      const keys = await this.redis.keys(pattern);
      
      for (const key of keys) {
        const ttl = await this.redis.ttl(key);
        if (ttl <= 0) {
          await this.redis.del(key);
        }
      }

      logger.info(`Cleaned up ${keys.length} expired sessions`);
    } catch (error) {
      logger.error('Error cleaning up expired sessions:', error);
    }
  }
}

// 创建并导出AI服务实例
const aiService = new AIService();
export default aiService;
```

## 6. 前端类型定义系统 (frontend/src/types/index.ts)

```typescript
// 基础类型定义
export interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  deleted?: boolean;
}

// 用户相关类型
export interface User extends BaseEntity {
  email: string;
  username: string;
  displayName: string;
  avatar?: string;
  role: UserRole;
  status: UserStatus;
  profile: UserProfile;
  preferences: UserPreferences;
  lastLoginAt?: Date;
  emailVerified: boolean;
  phoneVerified: boolean;
}

export enum UserRole {
  STUDENT = 'student',
  TEACHER = 'teacher',
  ADMIN = 'admin',
  SUPER_ADMIN = 'super_admin'
}

export enum UserStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  SUSPENDED = 'suspended',
  PENDING = 'pending'
}

export interface UserProfile {
  firstName: string;
  lastName: string;
  phone?: string;
  organization?: string;
  department?: string;
  grade?: string;
  bio?: string;
  location?: string;
  website?: string;
  socialLinks?: Record<string, string>;
}

export interface UserPreferences {
  language: string;
  theme: 'light' | 'dark' | 'auto';
  timezone: string;
  notifications: NotificationSettings;
  privacy: PrivacySettings;
  accessibility: AccessibilitySettings;
}

export interface NotificationSettings {
  email: boolean;
  push: boolean;
  sms: boolean;
  experimentReminders: boolean;
  systemUpdates: boolean;
  weeklyDigest: boolean;
}

export interface PrivacySettings {
  profileVisible: boolean;
  experimentsVisible: boolean;
  allowDataCollection: boolean;
  allowAnalytics: boolean;
}

export interface AccessibilitySettings {
  highContrast: boolean;
  largeText: boolean;
  screenReader: boolean;
  reducedMotion: boolean;
  keyboardNavigation: boolean;
}

// 实验相关类型
export interface Experiment extends BaseEntity {
  title: string;
  description: string;
  objectives: string[];
  instructions: ExperimentInstruction[];
  authorId: string;
  author: User;
  templateId?: string;
  template?: ExperimentTemplate;
  category: ExperimentCategory;
  difficulty: ExperimentDifficulty;
  estimatedDuration: number; // 分钟
  status: ExperimentStatus;
  visibility: ExperimentVisibility;
  tags: string[];
  resources: ExperimentResource[];
  requirements: ExperimentRequirement[];
  metadata: ExperimentMetadata;
  sessions: ExperimentSession[];
  analytics: ExperimentAnalytics;
  version: number;
  publishedAt?: Date;
  archivedAt?: Date;
}

export interface ExperimentInstruction {
  step: number;
  title: string;
  content: string;
  images?: string[];
  videos?: string[];
  interactive?: boolean;
  estimatedTime?: number;
  tips?: string[];
  warnings?: string[];
}

export enum ExperimentCategory {
  PHYSICS = 'physics',
  CHEMISTRY = 'chemistry',
  BIOLOGY = 'biology',
  MATHEMATICS = 'mathematics',
  COMPUTER_SCIENCE = 'computer_science',
  ENGINEERING = 'engineering',
  ENVIRONMENTAL = 'environmental',
  INTERDISCIPLINARY = 'interdisciplinary'
}

export enum ExperimentDifficulty {
  BEGINNER = 'beginner',
  INTERMEDIATE = 'intermediate',
  ADVANCED = 'advanced',
  EXPERT = 'expert'
}

export enum ExperimentStatus {
  DRAFT = 'draft',
  REVIEW = 'review',
  PUBLISHED = 'published',
  ARCHIVED = 'archived',
  DEPRECATED = 'deprecated'
}

export enum ExperimentVisibility {
  PUBLIC = 'public',
  PRIVATE = 'private',
  ORGANIZATION = 'organization',
   INVITED = 'invited'
}

export interface ExperimentResource {
  id: string;
  name: string;
  type: ResourceType;
  url?: string;
  content?: string;
  metadata?: Record<string, any>;
  required: boolean;
  quantity?: number;
  specifications?: Record<string, any>;
}

export enum ResourceType {
  EQUIPMENT = 'equipment',
  MATERIAL = 'material',
  SOFTWARE = 'software',
  DOCUMENT = 'document',
  VIDEO = 'video',
  LINK = 'link',
  FILE = 'file'
}

export interface ExperimentRequirement {
  type: RequirementType;
  description: string;
  level: RequirementLevel;
  optional: boolean;
}

export enum RequirementType {
  KNOWLEDGE = 'knowledge',
  SKILL = 'skill',
  EQUIPMENT = 'equipment',
  SOFTWARE = 'software',
  TIME = 'time',
  SPACE = 'space'
}

export enum RequirementLevel {
  BASIC = 'basic',
  INTERMEDIATE = 'intermediate',
  ADVANCED = 'advanced'
}

export interface ExperimentMetadata {
  keywords: string[];
  academicLevel: string[];
  subjects: string[];
  learningOutcomes: string[];
  assessmentMethods: string[];
  safetyConsiderations: string[];
  adaptations?: string[];
  extensions?: string[];
}

// 实验会话类型
export interface ExperimentSession extends BaseEntity {
  experimentId: string;
  experiment: Experiment;
  userId: string;
  user: User;
  groupId?: string;
  group?: ExperimentGroup;
  status: SessionStatus;
  startedAt?: Date;
  completedAt?: Date;
  pausedAt?: Date;
  duration: number; // 毫秒
  currentStep: number;
  totalSteps: number;
  progress: number; // 0-100
  data: SessionData;
  observations: Observation[];
  results: SessionResult[];
  feedback?: SessionFeedback;
  aiInteractions: AIInteraction[];
  metadata: Record<string, any>;
}

export enum SessionStatus {
  NOT_STARTED = 'not_started',
  IN_PROGRESS = 'in_progress',
  PAUSED = 'paused',
  COMPLETED = 'completed',
  ABANDONED = 'abandoned',
  ERROR = 'error'
}

export interface SessionData {
  stepProgress: StepProgress[];
  measurements: Measurement[];
  calculations: Calculation[];
  notes: Note[];
  attachments: Attachment[];
  variables: Record<string, any>;
  settings: Record<string, any>;
}

export interface StepProgress {
  stepNumber: number;
  status: StepStatus;
  startedAt?: Date;
  completedAt?: Date;
  duration?: number;
  attempts: number;
  errors: string[];
  data?: Record<string, any>;
}

export enum StepStatus {
  PENDING = 'pending',
  IN_PROGRESS = 'in_progress',
  COMPLETED = 'completed',
  SKIPPED = 'skipped',
  ERROR = 'error'
}

export interface Measurement {
  id: string;
  name: string;
  value: number | string;
  unit?: string;
  timestamp: Date;
  stepNumber?: number;
  metadata?: Record<string, any>;
  validated?: boolean;
  accuracy?: number;
}

export interface Calculation {
  id: string;
  name: string;
  formula: string;
  inputs: Record<string, number>;
  result: number;
  unit?: string;
  timestamp: Date;
  stepNumber?: number;
  validated?: boolean;
}

export interface Note {
  id: string;
  content: string;
  timestamp: Date;
  stepNumber?: number;
  tags?: string[];
  type: NoteType;
  attachments?: string[];
}

export enum NoteType {
  OBSERVATION = 'observation',
  QUESTION = 'question',
  IDEA = 'idea',
  ISSUE = 'issue',
  SOLUTION = 'solution',
  REMINDER = 'reminder'
}

export interface Attachment {
  id: string;
  name: string;
  type: AttachmentType;
  url: string;
  size: number;
  timestamp: Date;
  stepNumber?: number;
  metadata?: Record<string, any>;
}

export enum AttachmentType {
  IMAGE = 'image',
  VIDEO = 'video',
  AUDIO = 'audio',
  DOCUMENT = 'document',
  DATA = 'data',
  OTHER = 'other'
}

// AI相关类型
export interface AIInteraction extends BaseEntity {
  sessionId: string;
  userId: string;
  type: AIInteractionType;
  input: string;
  output: string;
  context?: Record<string, any>;
  modelUsed: string;
  confidence?: number;
  feedback?: AIFeedback;
  tokens: {
    prompt: number;
    completion: number;
    total: number;
  };
  duration: number;
  stepNumber?: number;
}

export enum AIInteractionType {
  QUESTION = 'question',
  GUIDANCE = 'guidance',
  EXPLANATION = 'explanation',
  ANALYSIS = 'analysis',
  SUGGESTION = 'suggestion',
  VALIDATION = 'validation',
  TROUBLESHOOTING = 'troubleshooting'
}

export interface AIFeedback {
  helpful: boolean;
  accurate: boolean;
  relevant: boolean;
  clear: boolean;
  rating: number; // 1-5
  comments?: string;
  timestamp: Date;
}

// 模板相关类型
export interface ExperimentTemplate extends BaseEntity {
  title: string;
  description: string;
  category: ExperimentCategory;
  difficulty: ExperimentDifficulty;
  objectives: string[];
  instructions: ExperimentInstruction[];
  resources: ExperimentResource[];
  requirements: ExperimentRequirement[];
  metadata: ExperimentMetadata;
  authorId: string;
  author: User;
  organizationId?: string;
  version: number;
  status: TemplateStatus;
  visibility: ExperimentVisibility;
  tags: string[];
  usage: TemplateUsage;
  ratings: TemplateRating[];
  reviews: TemplateReview[];
  forks: number;
  stars: number;
  downloads: number;
}

export enum TemplateStatus {
  DRAFT = 'draft',
  PUBLISHED = 'published',
  FEATURED = 'featured',
  DEPRECATED = 'deprecated',
  ARCHIVED = 'archived'
}

export interface TemplateUsage {
  totalUses: number;
  recentUses: number;
  averageRating: number;
  successRate: number;
  completionRate: number;
  averageDuration: number;
}

export interface TemplateRating {
  userId: string;
  rating: number; // 1-5
  timestamp: Date;
}

export interface TemplateReview {
  id: string;
  userId: string;
  user: User;
  rating: number; // 1-5
  title: string;
  content: string;
  pros?: string[];
  cons?: string[];
  recommendations?: string[];
  verified: boolean;
  helpful: number;
  timestamp: Date;
}

// API响应类型
export interface ApiResponse<T = any> {
  success: boolean;
  data: T;
  message?: string;
  errors?: ApiError[];
  pagination?: PaginationInfo;
  metadata?: Record<string, any>;
}

export interface ApiError {
  code: string;
  message: string;
  field?: string;
  details?: any;
}

export interface PaginationInfo {
  page: number;
  limit: number;
  total: number;
  totalPages: number;
  hasNext: boolean;
  hasPrev: boolean;
}

// 表单相关类型
export interface FormField {
  name: string;
  label: string;
  type: FormFieldType;
  required: boolean;
  validation?: ValidationRule[];
  options?: FormFieldOption[];
  placeholder?: string;
  helpText?: string;
  defaultValue?: any;
  disabled?: boolean;
  visible?: boolean;
}

export enum FormFieldType {
  TEXT = 'text',
  EMAIL = 'email',
  PASSWORD = 'password',
  NUMBER = 'number',
  TEXTAREA = 'textarea',
  SELECT = 'select',
  MULTISELECT = 'multiselect',
  CHECKBOX = 'checkbox',
  RADIO = 'radio',
  DATE = 'date',
  TIME = 'time',
  DATETIME = 'datetime',
  FILE = 'file',
  IMAGE = 'image',
  URL = 'url',
  COLOR = 'color',
  RANGE = 'range'
}

export interface FormFieldOption {
  label: string;
  value: any;
  disabled?: boolean;
  group?: string;
}

export interface ValidationRule {
  type: ValidationType;
  value?: any;
  message?: string;
  customValidator?: (value: any) => boolean | string;
}

export enum ValidationType {
  REQUIRED = 'required',
  MIN_LENGTH = 'minLength',
  MAX_LENGTH = 'maxLength',
  MIN_VALUE = 'minValue',
  MAX_VALUE = 'maxValue',
  PATTERN = 'pattern',
  EMAIL = 'email',
  URL = 'url',
  CUSTOM = 'custom'
}

// 权限相关类型
export interface Permission {
  id: string;
  name: string;
  description: string;
  resource: string;
  action: string;
  conditions?: Record<string, any>;
}

export interface Role {
  id: string;
  name: string;
  description: string;
  permissions: Permission[];
  hierarchy: number;
  system: boolean;
}

// 系统配置类型
export interface SystemConfig {
  features: FeatureConfig;
  limits: SystemLimits;
  integrations: IntegrationConfig;
  security: SecurityConfig;
  ui: UIConfig;
}

export interface FeatureConfig {
  aiAssistant: boolean;
  templates: boolean;
  collaboration: boolean;
  analytics: boolean;
  reporting: boolean;
  notifications: boolean;
  fileUpload: boolean;
  videoCall: boolean;
  chat: boolean;
  calendar: boolean;
}

export interface SystemLimits {
  maxExperimentsPerUser: number;
  maxSessionDuration: number;
  maxFileSize: number;
  maxStoragePerUser: number;
  maxGroupSize: number;
  maxTemplatesPerUser: number;
  rateLimits: Record<string, number>;
}

export interface IntegrationConfig {
  oauth: OAuthConfig;
  analytics: AnalyticsConfig;
  storage: StorageConfig;
  email: EmailConfig;
  sms: SMSConfig;
}

export interface OAuthConfig {
  google: boolean;
  microsoft: boolean;
  github: boolean;
  wechat: boolean;
}

export interface AnalyticsConfig {
  enabled: boolean;
  provider: string;
  trackingId: string;
  customEvents: boolean;
}

export interface StorageConfig {
  provider: string;
  bucket: string;
  region: string;
  cdn: boolean;
}

export interface EmailConfig {
  provider: string;
  from: string;
  templates: Record<string, string>;
}

export interface SMSConfig {
  provider: string;
  from: string;
  templates: Record<string, string>;
}

export interface SecurityConfig {
  passwordPolicy: PasswordPolicy;
  sessionTimeout: number;
  mfaRequired: boolean;
  ipWhitelist: string[];
  rateLimiting: boolean;
  encryption: EncryptionConfig;
}

export interface PasswordPolicy {
  minLength: number;
  requireUppercase: boolean;
  requireLowercase: boolean;
  requireNumbers: boolean;
  requireSpecialChars: boolean;
  maxAge: number;
  preventReuse: number;
}

export interface EncryptionConfig {
  algorithm: string;
  keyLength: number;
  saltRounds: number;
}

export interface UIConfig {
  theme: ThemeConfig;
  branding: BrandingConfig;
  layout: LayoutConfig;
  accessibility: AccessibilityConfig;
}

export interface ThemeConfig {
  primaryColor: string;
  secondaryColor: string;
  accentColor: string;
  errorColor: string;
  warningColor: string;
  successColor: string;
  infoColor: string;
  darkMode: boolean;
  customCss?: string;
}

export interface BrandingConfig {
  logo: string;
  favicon: string;
  title: string;
  description: string;
  footer: string;
  socialLinks: Record<string, string>;
}

export interface LayoutConfig {
  sidebar: SidebarConfig;
  header: HeaderConfig;
  footer: FooterConfig;
}

export interface SidebarConfig {
  collapsible: boolean;
  defaultCollapsed: boolean;
  position: 'left' | 'right';
  width: number;
}

export interface HeaderConfig {
  fixed: boolean;
  height: number;
  showSearch: boolean;
  showNotifications: boolean;
  showProfile: boolean;
}

export interface FooterConfig {
  show: boolean;
  height: number;
  content: string;
}

export interface AccessibilityConfig {
  highContrast: boolean;
  largeText: boolean;
  keyboardNavigation: boolean;
  screenReaderSupport: boolean;
  reducedMotion: boolean;
}

// 导出所有类型
export * from './api';
export * from './auth';
export * from './experiment';
export * from './template';
export * from './ai';
export * from './user';
export * from './form';
export * from './system';
```

## 7. 后端数据模型层 (backend/src/models/experiment.model.ts)

```typescript
import mongoose, { Schema, Document, Model } from 'mongoose';
import { User } from './user.model';
import { ExperimentTemplate } from './template.model';

// 实验状态枚举
export enum ExperimentStatus {
  DRAFT = 'draft',
  PUBLISHED = 'published',
  ARCHIVED = 'archived',
  UNDER_REVIEW = 'under_review'
}

// 实验可见性枚举
export enum ExperimentVisibility {
  PUBLIC = 'public',
  PRIVATE = 'private',
  ORGANIZATION = 'organization',
  INVITED_ONLY = 'invited_only'
}

// 实验类别枚举
export enum ExperimentCategory {
  PHYSICS = 'physics',
  CHEMISTRY = 'chemistry',
  BIOLOGY = 'biology',
  MATHEMATICS = 'mathematics',
  COMPUTER_SCIENCE = 'computer_science',
  ENGINEERING = 'engineering',
  ENVIRONMENTAL = 'environmental',
  INTERDISCIPLINARY = 'interdisciplinary'
}

// 实验难度枚举
export enum ExperimentDifficulty {
  BEGINNER = 'beginner',
  INTERMEDIATE = 'intermediate',
  ADVANCED = 'advanced',
  EXPERT = 'expert'
}

// 实验指令接口
export interface IExperimentInstruction {
  step: number;
  title: string;
  content: string;
  images?: string[];
  videos?: string[];
  interactive?: boolean;
  estimatedTime?: number; // 分钟
  tips?: string[];
  warnings?: string[];
  requirements?: string[];
  expectedResults?: string[];
}

// 实验资源接口
export interface IExperimentResource {
  id: string;
  name: string;
  type: 'equipment' | 'material' | 'software' | 'document' | 'video' | 'link';
  description?: string;
  url?: string;
  quantity?: number;
  required: boolean;
  specifications?: Record<string, any>;
  cost?: number;
  supplier?: string;
  alternatives?: string[];
}

// 实验要求接口
export interface IExperimentRequirement {
  type: 'knowledge' | 'skill' | 'equipment' | 'software' | 'time' | 'space';
  description: string;
  level: 'basic' | 'intermediate' | 'advanced';
  optional: boolean;
  details?: string;
}

// 实验元数据接口
export interface IExperimentMetadata {
  keywords: string[];
  academicLevel: string[];
  subjects: string[];
  learningOutcomes: string[];
  assessmentMethods: string[];
  safetyConsiderations: string[];
  adaptations?: string[];
  extensions?: string[];
  references?: string[];
  relatedExperiments?: string[];
}

// 实验分析接口
export interface IExperimentAnalytics {
  totalViews: number;
  totalStarts: number;
  totalCompletions: number;
  averageRating: number;
  totalRatings: number;
  averageDuration: number;
  successRate: number;
  abandonmentRate: number;
  stepAnalytics: IStepAnalytics[];
  userFeedback: IUserFeedback[];
  performanceMetrics: IPerformanceMetrics;
  lastAnalyzedAt: Date;
}

export interface IStepAnalytics {
  stepNumber: number;
  completionRate: number;
  averageTime: number;
  commonErrors: string[];
  helpRequests: number;
  skipRate: number;
}

export interface IUserFeedback {
  userId: string;
  rating: number; // 1-5
  comment?: string;
  category: 'difficulty' | 'clarity' | 'engagement' | 'relevance' | 'technical';
  helpful: boolean;
  timestamp: Date;
}

export interface IPerformanceMetrics {
  popularityScore: number;
  qualityScore: number;
  engagementScore: number;
  educationalValue: number;
  technicalComplexity: number;
  trending: boolean;
  featured: boolean;
}

// 实验文档接口
export interface IExperiment extends Document {
  title: string;
  description: string;
  shortDescription?: string;
  objectives: string[];
  instructions: IExperimentInstruction[];
  authorId: mongoose.Types.ObjectId;
  author?: IUser; // 虚拟字段
  templateId?: mongoose.Types.ObjectId;
  template?: IExperimentTemplate; // 虚拟字段
  category: ExperimentCategory;
  subcategory?: string;
  difficulty: ExperimentDifficulty;
  estimatedDuration: number; // 分钟
  status: ExperimentStatus;
  visibility: ExperimentVisibility;
  tags: string[];
  resources: IExperimentResource[];
  requirements: IExperimentRequirement[];
  metadata: IExperimentMetadata;
  analytics: IExperimentAnalytics;
  version: number;
  collaborators: mongoose.Types.ObjectId[];
  reviewers: mongoose.Types.ObjectId[];
  publishedAt?: Date;
  archivedAt?: Date;
  lastModifiedBy: mongoose.Types.ObjectId;
  changeLog: IChangeLogEntry[];
  
  // 虚拟字段
  sessions?: IExperimentSession[];
  ratings?: IExperimentRating[];
  
  // 实例方法
  publish(): Promise<IExperiment>;
  archive(): Promise<IExperiment>;
  addCollaborator(userId: mongoose.Types.ObjectId): Promise<IExperiment>;
  removeCollaborator(userId: mongoose.Types.ObjectId): Promise<IExperiment>;
  updateAnalytics(): Promise<IExperiment>;
  clone(newAuthorId: mongoose.Types.ObjectId): Promise<IExperiment>;
  isEditableBy(userId: mongoose.Types.ObjectId): boolean;
  isViewableBy(userId: mongoose.Types.ObjectId): boolean;
}

export interface IChangeLogEntry {
  version: number;
  changes: string[];
  modifiedBy: mongoose.Types.ObjectId;
  modifiedAt: Date;
  summary: string;
}

// 实验评分接口
export interface IExperimentRating {
  experimentId: mongoose.Types.ObjectId;
  userId: mongoose.Types.ObjectId;
  rating: number; // 1-5
  review?: string;
  aspects: {
    clarity: number;
    difficulty: number;
    engagement: number;
    usefulness: number;
  };
  createdAt: Date;
  updatedAt: Date;
}

// 定义Schema
const ExperimentInstructionSchema = new Schema<IExperimentInstruction>({
  step: { type: Number, required: true },
  title: { type: String, required: true, trim: true },
  content: { type: String, required: true },
  images: [{ type: String }],
  videos: [{ type: String }],
  interactive: { type: Boolean, default: false },
  estimatedTime: { type: Number, min: 0 },
  tips: [{ type: String }],
  warnings: [{ type: String }],
  requirements: [{ type: String }],
  expectedResults: [{ type: String }]
}, { _id: false });

const ExperimentResourceSchema = new Schema<IExperimentResource>({
  id: { type: String, required: true },
  name: { type: String, required: true, trim: true },
  type: { 
    type: String, 
    required: true,
    enum: ['equipment', 'material', 'software', 'document', 'video', 'link']
  },
  description: { type: String, trim: true },
  url: { type: String, trim: true },
  quantity: { type: Number, min: 0 },
  required: { type: Boolean, required: true },
  specifications: { type: Schema.Types.Mixed },
  cost: { type: Number, min: 0 },
  supplier: { type: String, trim: true },
  alternatives: [{ type: String }]
}, { _id: false });

const ExperimentRequirementSchema = new Schema<IExperimentRequirement>({
  type: { 
    type: String, 
    required: true,
    enum: ['knowledge', 'skill', 'equipment', 'software', 'time', 'space']
  },
  description: { type: String, required: true, trim: true },
  level: { 
    type: String, 
    required: true,
    enum: ['basic', 'intermediate', 'advanced']
  },
  optional: { type: Boolean, required: true },
  details: { type: String, trim: true }
}, { _id: false });

const ExperimentMetadataSchema = new Schema<IExperimentMetadata>({
  keywords: [{ type: String, trim: true }],
  academicLevel: [{ type: String, trim: true }],
  subjects: [{ type: String, trim: true }],
  learningOutcomes: [{ type: String, trim: true }],
  assessmentMethods: [{ type: String, trim: true }],
  safetyConsiderations: [{ type: String, trim: true }],
  adaptations: [{ type: String, trim: true }],
  extensions: [{ type: String, trim: true }],
  references: [{ type: String, trim: true }],
  relatedExperiments: [{ type: String, trim: true }]
}, { _id: false });

const StepAnalyticsSchema = new Schema<IStepAnalytics>({
  stepNumber: { type: Number, required: true },
  completionRate: { type: Number, default: 0, min: 0, max: 100 },
  averageTime: { type: Number, default: 0, min: 0 },
  commonErrors: [{ type: String }],
  helpRequests: { type: Number, default: 0, min: 0 },
  skipRate: { type: Number, default: 0, min: 0, max: 100 }
}, { _id: false });

const UserFeedbackSchema = new Schema<IUserFeedback>({
  userId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  rating: { type: Number, required: true, min: 1, max: 5 },
  comment: { type: String, trim: true },
  category: { 
    type: String,
    enum: ['difficulty', 'clarity', 'engagement', 'relevance', 'technical']
  },
  helpful: { type: Boolean, default: false },
  timestamp: { type: Date, default: Date.now }
}, { _id: false });

const PerformanceMetricsSchema = new Schema<IPerformanceMetrics>({
  popularityScore: { type: Number, default: 0, min: 0, max: 100 },
  qualityScore: { type: Number, default: 0, min: 0, max: 100 },
  engagementScore: { type: Number, default: 0, min: 0, max: 100 },
  educationalValue: { type: Number, default: 0, min: 0, max: 100 },
  technicalComplexity: { type: Number, default: 0, min: 0, max: 100 },
  trending: { type: Boolean, default: false },
  featured: { type: Boolean, default: false }
}, { _id: false });

const ExperimentAnalyticsSchema = new Schema<IExperimentAnalytics>({
  totalViews: { type: Number, default: 0, min: 0 },
  totalStarts: { type: Number, default: 0, min: 0 },
  totalCompletions: { type: Number, default: 0, min: 0 },
  averageRating: { type: Number, default: 0, min: 0, max: 5 },
  totalRatings: { type: Number, default: 0, min: 0 },
  averageDuration: { type: Number, default: 0, min: 0 },
  successRate: { type: Number, default: 0, min: 0, max: 100 },
  abandonmentRate: { type: Number, default: 0, min: 0, max: 100 },
  stepAnalytics: [StepAnalyticsSchema],
  userFeedback: [UserFeedbackSchema],
  performanceMetrics: PerformanceMetricsSchema,
  lastAnalyzedAt: { type: Date, default: Date.now }
}, { _id: false });

const ChangeLogEntrySchema = new Schema<IChangeLogEntry>({
  version: { type: Number, required: true },
  changes: [{ type: String, required: true }],
  modifiedBy: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  modifiedAt: { type: Date, default: Date.now },
  summary: { type: String, required: true, trim: true }
}, { _id: false });

// 主实验Schema
const ExperimentSchema = new Schema<IExperiment>({
  title: { 
    type: String, 
    required: true, 
    trim: true,
    maxlength: 200,
    index: true
  },
  description: { 
    type: String, 
    required: true,
    maxlength: 5000
  },
  shortDescription: { 
    type: String,
    maxlength: 300,
    trim: true
  },
  objectives: [{ 
    type: String, 
    required: true,
    trim: true,
    maxlength: 500
  }],
  instructions: [ExperimentInstructionSchema],
  authorId: { 
    type: Schema.Types.ObjectId, 
    ref: 'User', 
    required: true,
    index: true
  },
  templateId: { 
    type: Schema.Types.ObjectId, 
    ref: 'ExperimentTemplate',
    index: true
  },
  category: { 
    type: String, 
    required: true,
    enum: Object.values(ExperimentCategory),
    index: true
  },
  subcategory: { 
    type: String,
    trim: true,
    index: true
  },
  difficulty: { 
    type: String, 
    required: true,
    enum: Object.values(ExperimentDifficulty),
    index: true
  },
  estimatedDuration: { 
    type: Number, 
    required: true,
    min: 1,
    max: 10080 // 最大7天（分钟）
  },
  status: { 
    type: String, 
    required: true,
    enum: Object.values(ExperimentStatus),
    default: ExperimentStatus.DRAFT,
    index: true
  },
  visibility: { 
    type: String, 
    required: true,
    enum: Object.values(ExperimentVisibility),
    default: ExperimentVisibility.PRIVATE,
    index: true
  },
  tags: [{ 
    type: String, 
    trim: true,
    lowercase: true,
    index: true
  }],
  resources: [ExperimentResourceSchema],
  requirements: [ExperimentRequirementSchema],
  metadata: ExperimentMetadataSchema,
  analytics: { 
    type: ExperimentAnalyticsSchema,
    default: () => ({})
  },
  version: { 
    type: Number, 
    default: 1,
    min: 1
  },
  collaborators: [{ 
    type: Schema.Types.ObjectId, 
    ref: 'User',
    index: true
  }],
  reviewers: [{ 
    type: Schema.Types.ObjectId, 
    ref: 'User'
  }],
  publishedAt: { 
    type: Date,
    index: true
  },
  archivedAt: { 
    type: Date,
    index: true
  },
  lastModifiedBy: { 
    type: Schema.Types.ObjectId, 
    ref: 'User',
    required: true
  },
  changeLog: [ChangeLogEntrySchema]
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// 索引定义
ExperimentSchema.index({ title: 'text', description: 'text', 'metadata.keywords': 'text' });
ExperimentSchema.index({ category: 1, difficulty: 1, status: 1 });
ExperimentSchema.index({ authorId: 1, status: 1 });
ExperimentSchema.index({ publishedAt: -1, status: 1 });
ExperimentSchema.index({ 'analytics.averageRating': -1, 'analytics.totalRatings': -1 });
ExperimentSchema.index({ 'analytics.performanceMetrics.popularityScore': -1 });
ExperimentSchema.index({ tags: 1, category: 1 });

// 虚拟字段
ExperimentSchema.virtual('author', {
  ref: 'User',
  localField: 'authorId',
  foreignField: '_id',
  justOne: true
});

ExperimentSchema.virtual('template', {
  ref: 'ExperimentTemplate',
  localField: 'templateId',
  foreignField: '_id',
  justOne: true
});

ExperimentSchema.virtual('sessions', {
  ref: 'ExperimentSession',
  localField: '_id',
  foreignField: 'experimentId'
});

ExperimentSchema.virtual('ratings', {
  ref: 'ExperimentRating',
  localField: '_id',
  foreignField: 'experimentId'
});

// 实例方法
ExperimentSchema.methods.publish = async function(this: IExperiment): Promise<IExperiment> {
  this.status = ExperimentStatus.PUBLISHED;
  this.publishedAt = new Date();
  this.version += 1;
  
  this.changeLog.push({
    version: this.version,
    changes: ['Published experiment'],
    modifiedBy: this.lastModifiedBy,
    modifiedAt: new Date(),
    summary: 'Experiment published'
  });
  
  return this.save();
};

ExperimentSchema.methods.archive = async function(this: IExperiment): Promise<IExperiment> {
  this.status = ExperimentStatus.ARCHIVED;
  this.archivedAt = new Date();
  
  this.changeLog.push({
    version: this.version,
    changes: ['Archived experiment'],
    modifiedBy: this.lastModifiedBy,
    modifiedAt: new Date(),
    summary: 'Experiment archived'
  });
  
  return this.save();
};

ExperimentSchema.methods.addCollaborator = async function(
  this: IExperiment, 
  userId: mongoose.Types.ObjectId
): Promise<IExperiment> {
  if (!this.collaborators.includes(userId)) {
    this.collaborators.push(userId);
    
    this.changeLog.push({
      version: this.version,
      changes: [`Added collaborator: ${userId}`],
      modifiedBy: this.lastModifiedBy,
      modifiedAt: new Date(),
      summary: 'Collaborator added'
    });
  }
  
  return this.save();
};

ExperimentSchema.methods.removeCollaborator = async function(
  this: IExperiment, 
  userId: mongoose.Types.ObjectId
): Promise<IExperiment> {
  this.collaborators = this.collaborators.filter(id => !id.equals(userId));
  
  this.changeLog.push({
    version: this.version,
    changes: [`Removed collaborator: ${userId}`],
    modifiedBy: this.lastModifiedBy,
    modifiedAt: new Date(),
    summary: 'Collaborator removed'
  });
  
  return this.save();
};

ExperimentSchema.methods.updateAnalytics = async function(this: IExperiment): Promise<IExperiment> {
  // 这里实现分析数据更新逻辑
  this.analytics.lastAnalyzedAt = new Date();
  return this.save();
};

ExperimentSchema.methods.clone = async function(
  this: IExperiment, 
  newAuthorId: mongoose.Types.ObjectId
): Promise<IExperiment> {
  const ExperimentModel = this.constructor as Model<IExperiment>;
  
  const clonedData = this.toObject();
  delete clonedData._id;
  delete clonedData.createdAt;
  delete clonedData.updatedAt;
  
  clonedData.authorId = newAuthorId;
  clonedData.lastModifiedBy = newAuthorId;
  clonedData.title = `${clonedData.title} (副本)`;
  clonedData.status = ExperimentStatus.DRAFT;
  clonedData.visibility = ExperimentVisibility.PRIVATE;
  clonedData.publishedAt = undefined;
  clonedData.archivedAt = undefined;
  clonedData.version = 1;
  clonedData.collaborators = [];
  clonedData.reviewers = [];
  clonedData.analytics = {};
  clonedData.changeLog = [{
    version: 1,
    changes: [`Cloned from experiment: ${this._id}`],
    modifiedBy: newAuthorId,
    modifiedAt: new Date(),
    summary: 'Experiment cloned'
  }];
  
  return new ExperimentModel(clonedData).save();
};

ExperimentSchema.methods.isEditableBy = function(
  this: IExperiment, 
  userId: mongoose.Types.ObjectId
): boolean {
  return this.authorId.equals(userId) || 
         this.collaborators.some(id => id.equals(userId));
};

ExperimentSchema.methods.isViewableBy = function(
  this: IExperiment, 
  userId: mongoose.Types.ObjectId
): boolean {
  if (this.visibility === ExperimentVisibility.PUBLIC) {
    return true;
  }
  
  if (this.visibility === ExperimentVisibility.PRIVATE) {
    return this.isEditableBy(userId);
  }
  
  // 其他可见性检查逻辑
  return false;
};

// 静态方法
ExperimentSchema.statics.findPublished = function() {
  return this.find({ 
    status: ExperimentStatus.PUBLISHED,
    visibility: { $ne: ExperimentVisibility.PRIVATE }
  });
};

ExperimentSchema.statics.findByCategory = function(category: ExperimentCategory) {
  return this.find({ category, status: ExperimentStatus.PUBLISHED });
};

ExperimentSchema.statics.findFeatured = function() {
  return this.find({ 
    'analytics.performanceMetrics.featured': true,
    status: ExperimentStatus.PUBLISHED
  });
};

// 中间件
ExperimentSchema.pre('save', function(next) {
  if (this.isModified() && !this.isNew) {
    this.version += 1;
  }
  next();
});

ExperimentSchema.pre('remove', function(next) {
  // 清理相关数据
  // 这里可以添加删除相关会话、评分等数据的逻辑
  next();
});
